schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

scalar _int4

# expression to compare columns of type _int4. All fields are combined with logical 'AND'.
input _int4_comparison_exp {
  _eq: _int4
  _gt: _int4
  _gte: _int4
  _in: [_int4!]
  _is_null: Boolean
  _lt: _int4
  _lte: _int4
  _neq: _int4
  _nin: [_int4!]
}

scalar _numeric

# expression to compare columns of type _numeric. All fields are combined with logical 'AND'.
input _numeric_comparison_exp {
  _eq: _numeric
  _gt: _numeric
  _gte: _numeric
  _in: [_numeric!]
  _is_null: Boolean
  _lt: _numeric
  _lte: _numeric
  _neq: _numeric
  _nin: [_numeric!]
}

scalar _text

# expression to compare columns of type _text. All fields are combined with logical 'AND'.
input _text_comparison_exp {
  _eq: _text
  _gt: _text
  _gte: _text
  _in: [_text!]
  _is_null: Boolean
  _lt: _text
  _lte: _text
  _neq: _text
  _nin: [_text!]
}

# columns and relationships of "actors"
type actors {
  first_name: String!
  id: Int!
  last_name: String!
  last_update: timestamp!
}

# aggregated selection of "actors"
type actors_aggregate {
  aggregate: actors_aggregate_fields
  nodes: [actors!]!
}

# aggregate fields of "actors"
type actors_aggregate_fields {
  avg: actors_avg_fields
  count(columns: [actors_select_column!], distinct: Boolean): Int
  max: actors_max_fields
  min: actors_min_fields
  stddev: actors_stddev_fields
  stddev_pop: actors_stddev_pop_fields
  stddev_samp: actors_stddev_samp_fields
  sum: actors_sum_fields
  var_pop: actors_var_pop_fields
  var_samp: actors_var_samp_fields
  variance: actors_variance_fields
}

# order by aggregate values of table "actors"
input actors_aggregate_order_by {
  avg: actors_avg_order_by
  count: order_by
  max: actors_max_order_by
  min: actors_min_order_by
  stddev: actors_stddev_order_by
  stddev_pop: actors_stddev_pop_order_by
  stddev_samp: actors_stddev_samp_order_by
  sum: actors_sum_order_by
  var_pop: actors_var_pop_order_by
  var_samp: actors_var_samp_order_by
  variance: actors_variance_order_by
}

# input type for inserting array relation for remote table "actors"
input actors_arr_rel_insert_input {
  data: [actors_insert_input!]!
  on_conflict: actors_on_conflict
}

# aggregate avg on columns
type actors_avg_fields {
  id: Float
}

# order by avg() on columns of table "actors"
input actors_avg_order_by {
  id: order_by
}

# Boolean expression to filter rows from the table "actors". All fields are combined with a logical 'AND'.
input actors_bool_exp {
  _and: [actors_bool_exp]
  _not: actors_bool_exp
  _or: [actors_bool_exp]
  first_name: String_comparison_exp
  id: Int_comparison_exp
  last_name: String_comparison_exp
  last_update: timestamp_comparison_exp
}

# unique or primary key constraints on table "actors"
enum actors_constraint {
  # unique or primary key constraint
  actors_pkey
}

# input type for incrementing integer column in table "actors"
input actors_inc_input {
  id: Int
}

# input type for inserting data into table "actors"
input actors_insert_input {
  first_name: String
  id: Int
  last_name: String
  last_update: timestamp
}

# aggregate max on columns
type actors_max_fields {
  first_name: String
  id: Int
  last_name: String
  last_update: timestamp
}

# order by max() on columns of table "actors"
input actors_max_order_by {
  first_name: order_by
  id: order_by
  last_name: order_by
  last_update: order_by
}

# aggregate min on columns
type actors_min_fields {
  first_name: String
  id: Int
  last_name: String
  last_update: timestamp
}

# order by min() on columns of table "actors"
input actors_min_order_by {
  first_name: order_by
  id: order_by
  last_name: order_by
  last_update: order_by
}

# response of any mutation on the table "actors"
type actors_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [actors!]!
}

# input type for inserting object relation for remote table "actors"
input actors_obj_rel_insert_input {
  data: actors_insert_input!
  on_conflict: actors_on_conflict
}

# on conflict condition type for table "actors"
input actors_on_conflict {
  constraint: actors_constraint!
  update_columns: [actors_update_column!]!
  where: actors_bool_exp
}

# ordering options when selecting data from "actors"
input actors_order_by {
  first_name: order_by
  id: order_by
  last_name: order_by
  last_update: order_by
}

# primary key columns input for table: "actors"
input actors_pk_columns_input {
  id: Int!
}

# select columns of table "actors"
enum actors_select_column {
  # column name
  first_name

  # column name
  id

  # column name
  last_name

  # column name
  last_update
}

# input type for updating data in table "actors"
input actors_set_input {
  first_name: String
  id: Int
  last_name: String
  last_update: timestamp
}

# aggregate stddev on columns
type actors_stddev_fields {
  id: Float
}

# order by stddev() on columns of table "actors"
input actors_stddev_order_by {
  id: order_by
}

# aggregate stddev_pop on columns
type actors_stddev_pop_fields {
  id: Float
}

# order by stddev_pop() on columns of table "actors"
input actors_stddev_pop_order_by {
  id: order_by
}

# aggregate stddev_samp on columns
type actors_stddev_samp_fields {
  id: Float
}

# order by stddev_samp() on columns of table "actors"
input actors_stddev_samp_order_by {
  id: order_by
}

# aggregate sum on columns
type actors_sum_fields {
  id: Int
}

# order by sum() on columns of table "actors"
input actors_sum_order_by {
  id: order_by
}

# update columns of table "actors"
enum actors_update_column {
  # column name
  first_name

  # column name
  id

  # column name
  last_name

  # column name
  last_update
}

# aggregate var_pop on columns
type actors_var_pop_fields {
  id: Float
}

# order by var_pop() on columns of table "actors"
input actors_var_pop_order_by {
  id: order_by
}

# aggregate var_samp on columns
type actors_var_samp_fields {
  id: Float
}

# order by var_samp() on columns of table "actors"
input actors_var_samp_order_by {
  id: order_by
}

# aggregate variance on columns
type actors_variance_fields {
  id: Float
}

# order by variance() on columns of table "actors"
input actors_variance_order_by {
  id: order_by
}

# columns and relationships of "albums"
type albums {
  # An object relationship
  artist: artists!
  artist_id: Int!

  # A computed field, executes function "get_artist_name"
  full_name: String
  id: Int!
  title: String!

  # An array relationship
  tracks(
    # distinct select on columns
    distinct_on: [tracks_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [tracks_order_by!]

    # filter the rows returned
    where: tracks_bool_exp
  ): [tracks!]!

  # An aggregated array relationship
  tracks_aggregate(
    # distinct select on columns
    distinct_on: [tracks_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [tracks_order_by!]

    # filter the rows returned
    where: tracks_bool_exp
  ): tracks_aggregate!
  updated_at: timestamptz
}

# aggregated selection of "albums"
type albums_aggregate {
  aggregate: albums_aggregate_fields
  nodes: [albums!]!
}

# aggregate fields of "albums"
type albums_aggregate_fields {
  avg: albums_avg_fields
  count(columns: [albums_select_column!], distinct: Boolean): Int
  max: albums_max_fields
  min: albums_min_fields
  stddev: albums_stddev_fields
  stddev_pop: albums_stddev_pop_fields
  stddev_samp: albums_stddev_samp_fields
  sum: albums_sum_fields
  var_pop: albums_var_pop_fields
  var_samp: albums_var_samp_fields
  variance: albums_variance_fields
}

# order by aggregate values of table "albums"
input albums_aggregate_order_by {
  avg: albums_avg_order_by
  count: order_by
  max: albums_max_order_by
  min: albums_min_order_by
  stddev: albums_stddev_order_by
  stddev_pop: albums_stddev_pop_order_by
  stddev_samp: albums_stddev_samp_order_by
  sum: albums_sum_order_by
  var_pop: albums_var_pop_order_by
  var_samp: albums_var_samp_order_by
  variance: albums_variance_order_by
}

# input type for inserting array relation for remote table "albums"
input albums_arr_rel_insert_input {
  data: [albums_insert_input!]!
  on_conflict: albums_on_conflict
}

# aggregate avg on columns
type albums_avg_fields {
  artist_id: Float
  id: Float
}

# order by avg() on columns of table "albums"
input albums_avg_order_by {
  artist_id: order_by
  id: order_by
}

# Boolean expression to filter rows from the table "albums". All fields are combined with a logical 'AND'.
input albums_bool_exp {
  _and: [albums_bool_exp]
  _not: albums_bool_exp
  _or: [albums_bool_exp]
  artist: artists_bool_exp
  artist_id: Int_comparison_exp
  id: Int_comparison_exp
  title: String_comparison_exp
  tracks: tracks_bool_exp
  updated_at: timestamptz_comparison_exp
}

# unique or primary key constraints on table "albums"
enum albums_constraint {
  # unique or primary key constraint
  pk_albums
}

# input type for incrementing integer column in table "albums"
input albums_inc_input {
  artist_id: Int
  id: Int
}

# input type for inserting data into table "albums"
input albums_insert_input {
  artist: artists_obj_rel_insert_input
  artist_id: Int
  id: Int
  title: String
  tracks: tracks_arr_rel_insert_input
  updated_at: timestamptz
}

# aggregate max on columns
type albums_max_fields {
  artist_id: Int
  id: Int
  title: String
  updated_at: timestamptz
}

# order by max() on columns of table "albums"
input albums_max_order_by {
  artist_id: order_by
  id: order_by
  title: order_by
  updated_at: order_by
}

# aggregate min on columns
type albums_min_fields {
  artist_id: Int
  id: Int
  title: String
  updated_at: timestamptz
}

# order by min() on columns of table "albums"
input albums_min_order_by {
  artist_id: order_by
  id: order_by
  title: order_by
  updated_at: order_by
}

# response of any mutation on the table "albums"
type albums_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [albums!]!
}

# input type for inserting object relation for remote table "albums"
input albums_obj_rel_insert_input {
  data: albums_insert_input!
  on_conflict: albums_on_conflict
}

# on conflict condition type for table "albums"
input albums_on_conflict {
  constraint: albums_constraint!
  update_columns: [albums_update_column!]!
  where: albums_bool_exp
}

# ordering options when selecting data from "albums"
input albums_order_by {
  artist: artists_order_by
  artist_id: order_by
  id: order_by
  title: order_by
  tracks_aggregate: tracks_aggregate_order_by
  updated_at: order_by
}

# primary key columns input for table: "albums"
input albums_pk_columns_input {
  id: Int!
}

# select columns of table "albums"
enum albums_select_column {
  # column name
  artist_id

  # column name
  id

  # column name
  title

  # column name
  updated_at
}

# input type for updating data in table "albums"
input albums_set_input {
  artist_id: Int
  id: Int
  title: String
  updated_at: timestamptz
}

# aggregate stddev on columns
type albums_stddev_fields {
  artist_id: Float
  id: Float
}

# order by stddev() on columns of table "albums"
input albums_stddev_order_by {
  artist_id: order_by
  id: order_by
}

# aggregate stddev_pop on columns
type albums_stddev_pop_fields {
  artist_id: Float
  id: Float
}

# order by stddev_pop() on columns of table "albums"
input albums_stddev_pop_order_by {
  artist_id: order_by
  id: order_by
}

# aggregate stddev_samp on columns
type albums_stddev_samp_fields {
  artist_id: Float
  id: Float
}

# order by stddev_samp() on columns of table "albums"
input albums_stddev_samp_order_by {
  artist_id: order_by
  id: order_by
}

# aggregate sum on columns
type albums_sum_fields {
  artist_id: Int
  id: Int
}

# order by sum() on columns of table "albums"
input albums_sum_order_by {
  artist_id: order_by
  id: order_by
}

# update columns of table "albums"
enum albums_update_column {
  # column name
  artist_id

  # column name
  id

  # column name
  title

  # column name
  updated_at
}

# aggregate var_pop on columns
type albums_var_pop_fields {
  artist_id: Float
  id: Float
}

# order by var_pop() on columns of table "albums"
input albums_var_pop_order_by {
  artist_id: order_by
  id: order_by
}

# aggregate var_samp on columns
type albums_var_samp_fields {
  artist_id: Float
  id: Float
}

# order by var_samp() on columns of table "albums"
input albums_var_samp_order_by {
  artist_id: order_by
  id: order_by
}

# aggregate variance on columns
type albums_variance_fields {
  artist_id: Float
  id: Float
}

# order by variance() on columns of table "albums"
input albums_variance_order_by {
  artist_id: order_by
  id: order_by
}

# columns and relationships of "artists"
type artists {
  # An array relationship
  albums(
    # distinct select on columns
    distinct_on: [albums_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [albums_order_by!]

    # filter the rows returned
    where: albums_bool_exp
  ): [albums!]!

  # An aggregated array relationship
  albums_aggregate(
    # distinct select on columns
    distinct_on: [albums_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [albums_order_by!]

    # filter the rows returned
    where: albums_bool_exp
  ): albums_aggregate!
  id: Int!
  name: String
}

# aggregated selection of "artists"
type artists_aggregate {
  aggregate: artists_aggregate_fields
  nodes: [artists!]!
}

# aggregate fields of "artists"
type artists_aggregate_fields {
  avg: artists_avg_fields
  count(columns: [artists_select_column!], distinct: Boolean): Int
  max: artists_max_fields
  min: artists_min_fields
  stddev: artists_stddev_fields
  stddev_pop: artists_stddev_pop_fields
  stddev_samp: artists_stddev_samp_fields
  sum: artists_sum_fields
  var_pop: artists_var_pop_fields
  var_samp: artists_var_samp_fields
  variance: artists_variance_fields
}

# order by aggregate values of table "artists"
input artists_aggregate_order_by {
  avg: artists_avg_order_by
  count: order_by
  max: artists_max_order_by
  min: artists_min_order_by
  stddev: artists_stddev_order_by
  stddev_pop: artists_stddev_pop_order_by
  stddev_samp: artists_stddev_samp_order_by
  sum: artists_sum_order_by
  var_pop: artists_var_pop_order_by
  var_samp: artists_var_samp_order_by
  variance: artists_variance_order_by
}

# input type for inserting array relation for remote table "artists"
input artists_arr_rel_insert_input {
  data: [artists_insert_input!]!
  on_conflict: artists_on_conflict
}

# aggregate avg on columns
type artists_avg_fields {
  id: Float
}

# order by avg() on columns of table "artists"
input artists_avg_order_by {
  id: order_by
}

# Boolean expression to filter rows from the table "artists". All fields are combined with a logical 'AND'.
input artists_bool_exp {
  _and: [artists_bool_exp]
  _not: artists_bool_exp
  _or: [artists_bool_exp]
  albums: albums_bool_exp
  id: Int_comparison_exp
  name: String_comparison_exp
}

# unique or primary key constraints on table "artists"
enum artists_constraint {
  # unique or primary key constraint
  pk_artists
}

# input type for incrementing integer column in table "artists"
input artists_inc_input {
  id: Int
}

# input type for inserting data into table "artists"
input artists_insert_input {
  albums: albums_arr_rel_insert_input
  id: Int
  name: String
}

# aggregate max on columns
type artists_max_fields {
  id: Int
  name: String
}

# order by max() on columns of table "artists"
input artists_max_order_by {
  id: order_by
  name: order_by
}

# aggregate min on columns
type artists_min_fields {
  id: Int
  name: String
}

# order by min() on columns of table "artists"
input artists_min_order_by {
  id: order_by
  name: order_by
}

# response of any mutation on the table "artists"
type artists_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [artists!]!
}

# input type for inserting object relation for remote table "artists"
input artists_obj_rel_insert_input {
  data: artists_insert_input!
  on_conflict: artists_on_conflict
}

# on conflict condition type for table "artists"
input artists_on_conflict {
  constraint: artists_constraint!
  update_columns: [artists_update_column!]!
  where: artists_bool_exp
}

# ordering options when selecting data from "artists"
input artists_order_by {
  albums_aggregate: albums_aggregate_order_by
  id: order_by
  name: order_by
}

# primary key columns input for table: "artists"
input artists_pk_columns_input {
  id: Int!
}

# select columns of table "artists"
enum artists_select_column {
  # column name
  id

  # column name
  name
}

# input type for updating data in table "artists"
input artists_set_input {
  id: Int
  name: String
}

# aggregate stddev on columns
type artists_stddev_fields {
  id: Float
}

# order by stddev() on columns of table "artists"
input artists_stddev_order_by {
  id: order_by
}

# aggregate stddev_pop on columns
type artists_stddev_pop_fields {
  id: Float
}

# order by stddev_pop() on columns of table "artists"
input artists_stddev_pop_order_by {
  id: order_by
}

# aggregate stddev_samp on columns
type artists_stddev_samp_fields {
  id: Float
}

# order by stddev_samp() on columns of table "artists"
input artists_stddev_samp_order_by {
  id: order_by
}

# aggregate sum on columns
type artists_sum_fields {
  id: Int
}

# order by sum() on columns of table "artists"
input artists_sum_order_by {
  id: order_by
}

# update columns of table "artists"
enum artists_update_column {
  # column name
  id

  # column name
  name
}

# aggregate var_pop on columns
type artists_var_pop_fields {
  id: Float
}

# order by var_pop() on columns of table "artists"
input artists_var_pop_order_by {
  id: order_by
}

# aggregate var_samp on columns
type artists_var_samp_fields {
  id: Float
}

# order by var_samp() on columns of table "artists"
input artists_var_samp_order_by {
  id: order_by
}

# aggregate variance on columns
type artists_variance_fields {
  id: Float
}

# order by variance() on columns of table "artists"
input artists_variance_order_by {
  id: order_by
}

# expression to compare columns of type Boolean. All fields are combined with logical 'AND'.
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

# columns and relationships of "categories"
type categories {
  id: Int!
  last_update: timestamp!
  name: String!
}

# aggregated selection of "categories"
type categories_aggregate {
  aggregate: categories_aggregate_fields
  nodes: [categories!]!
}

# aggregate fields of "categories"
type categories_aggregate_fields {
  avg: categories_avg_fields
  count(columns: [categories_select_column!], distinct: Boolean): Int
  max: categories_max_fields
  min: categories_min_fields
  stddev: categories_stddev_fields
  stddev_pop: categories_stddev_pop_fields
  stddev_samp: categories_stddev_samp_fields
  sum: categories_sum_fields
  var_pop: categories_var_pop_fields
  var_samp: categories_var_samp_fields
  variance: categories_variance_fields
}

# order by aggregate values of table "categories"
input categories_aggregate_order_by {
  avg: categories_avg_order_by
  count: order_by
  max: categories_max_order_by
  min: categories_min_order_by
  stddev: categories_stddev_order_by
  stddev_pop: categories_stddev_pop_order_by
  stddev_samp: categories_stddev_samp_order_by
  sum: categories_sum_order_by
  var_pop: categories_var_pop_order_by
  var_samp: categories_var_samp_order_by
  variance: categories_variance_order_by
}

# input type for inserting array relation for remote table "categories"
input categories_arr_rel_insert_input {
  data: [categories_insert_input!]!
  on_conflict: categories_on_conflict
}

# aggregate avg on columns
type categories_avg_fields {
  id: Float
}

# order by avg() on columns of table "categories"
input categories_avg_order_by {
  id: order_by
}

# Boolean expression to filter rows from the table "categories". All fields are combined with a logical 'AND'.
input categories_bool_exp {
  _and: [categories_bool_exp]
  _not: categories_bool_exp
  _or: [categories_bool_exp]
  id: Int_comparison_exp
  last_update: timestamp_comparison_exp
  name: String_comparison_exp
}

# unique or primary key constraints on table "categories"
enum categories_constraint {
  # unique or primary key constraint
  categories_pkey
}

# input type for incrementing integer column in table "categories"
input categories_inc_input {
  id: Int
}

# input type for inserting data into table "categories"
input categories_insert_input {
  id: Int
  last_update: timestamp
  name: String
}

# aggregate max on columns
type categories_max_fields {
  id: Int
  last_update: timestamp
  name: String
}

# order by max() on columns of table "categories"
input categories_max_order_by {
  id: order_by
  last_update: order_by
  name: order_by
}

# aggregate min on columns
type categories_min_fields {
  id: Int
  last_update: timestamp
  name: String
}

# order by min() on columns of table "categories"
input categories_min_order_by {
  id: order_by
  last_update: order_by
  name: order_by
}

# response of any mutation on the table "categories"
type categories_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [categories!]!
}

# input type for inserting object relation for remote table "categories"
input categories_obj_rel_insert_input {
  data: categories_insert_input!
  on_conflict: categories_on_conflict
}

# on conflict condition type for table "categories"
input categories_on_conflict {
  constraint: categories_constraint!
  update_columns: [categories_update_column!]!
  where: categories_bool_exp
}

# ordering options when selecting data from "categories"
input categories_order_by {
  id: order_by
  last_update: order_by
  name: order_by
}

# primary key columns input for table: "categories"
input categories_pk_columns_input {
  id: Int!
}

# select columns of table "categories"
enum categories_select_column {
  # column name
  id

  # column name
  last_update

  # column name
  name
}

# input type for updating data in table "categories"
input categories_set_input {
  id: Int
  last_update: timestamp
  name: String
}

# aggregate stddev on columns
type categories_stddev_fields {
  id: Float
}

# order by stddev() on columns of table "categories"
input categories_stddev_order_by {
  id: order_by
}

# aggregate stddev_pop on columns
type categories_stddev_pop_fields {
  id: Float
}

# order by stddev_pop() on columns of table "categories"
input categories_stddev_pop_order_by {
  id: order_by
}

# aggregate stddev_samp on columns
type categories_stddev_samp_fields {
  id: Float
}

# order by stddev_samp() on columns of table "categories"
input categories_stddev_samp_order_by {
  id: order_by
}

# aggregate sum on columns
type categories_sum_fields {
  id: Int
}

# order by sum() on columns of table "categories"
input categories_sum_order_by {
  id: order_by
}

# update columns of table "categories"
enum categories_update_column {
  # column name
  id

  # column name
  last_update

  # column name
  name
}

# aggregate var_pop on columns
type categories_var_pop_fields {
  id: Float
}

# order by var_pop() on columns of table "categories"
input categories_var_pop_order_by {
  id: order_by
}

# aggregate var_samp on columns
type categories_var_samp_fields {
  id: Float
}

# order by var_samp() on columns of table "categories"
input categories_var_samp_order_by {
  id: order_by
}

# aggregate variance on columns
type categories_variance_fields {
  id: Float
}

# order by variance() on columns of table "categories"
input categories_variance_order_by {
  id: order_by
}

# columns and relationships of "customers"
type customers {
  address: String
  city: String
  company: String
  country: String
  email: String!

  # An object relationship
  employee: employees
  fax: String
  first_name: String!
  id: Int!

  # An array relationship
  invoices(
    # distinct select on columns
    distinct_on: [invoices_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [invoices_order_by!]

    # filter the rows returned
    where: invoices_bool_exp
  ): [invoices!]!

  # An aggregated array relationship
  invoices_aggregate(
    # distinct select on columns
    distinct_on: [invoices_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [invoices_order_by!]

    # filter the rows returned
    where: invoices_bool_exp
  ): invoices_aggregate!
  last_name: String!
  phone: String
  postal_code: String
  state: String
  support_rep_id: Int
}

# aggregated selection of "customers"
type customers_aggregate {
  aggregate: customers_aggregate_fields
  nodes: [customers!]!
}

# aggregate fields of "customers"
type customers_aggregate_fields {
  avg: customers_avg_fields
  count(columns: [customers_select_column!], distinct: Boolean): Int
  max: customers_max_fields
  min: customers_min_fields
  stddev: customers_stddev_fields
  stddev_pop: customers_stddev_pop_fields
  stddev_samp: customers_stddev_samp_fields
  sum: customers_sum_fields
  var_pop: customers_var_pop_fields
  var_samp: customers_var_samp_fields
  variance: customers_variance_fields
}

# order by aggregate values of table "customers"
input customers_aggregate_order_by {
  avg: customers_avg_order_by
  count: order_by
  max: customers_max_order_by
  min: customers_min_order_by
  stddev: customers_stddev_order_by
  stddev_pop: customers_stddev_pop_order_by
  stddev_samp: customers_stddev_samp_order_by
  sum: customers_sum_order_by
  var_pop: customers_var_pop_order_by
  var_samp: customers_var_samp_order_by
  variance: customers_variance_order_by
}

# input type for inserting array relation for remote table "customers"
input customers_arr_rel_insert_input {
  data: [customers_insert_input!]!
  on_conflict: customers_on_conflict
}

# aggregate avg on columns
type customers_avg_fields {
  id: Float
  support_rep_id: Float
}

# order by avg() on columns of table "customers"
input customers_avg_order_by {
  id: order_by
  support_rep_id: order_by
}

# Boolean expression to filter rows from the table "customers". All fields are combined with a logical 'AND'.
input customers_bool_exp {
  _and: [customers_bool_exp]
  _not: customers_bool_exp
  _or: [customers_bool_exp]
  address: String_comparison_exp
  city: String_comparison_exp
  company: String_comparison_exp
  country: String_comparison_exp
  email: String_comparison_exp
  employee: employees_bool_exp
  fax: String_comparison_exp
  first_name: String_comparison_exp
  id: Int_comparison_exp
  invoices: invoices_bool_exp
  last_name: String_comparison_exp
  phone: String_comparison_exp
  postal_code: String_comparison_exp
  state: String_comparison_exp
  support_rep_id: Int_comparison_exp
}

# unique or primary key constraints on table "customers"
enum customers_constraint {
  # unique or primary key constraint
  pk_customers
}

# input type for incrementing integer column in table "customers"
input customers_inc_input {
  id: Int
  support_rep_id: Int
}

# input type for inserting data into table "customers"
input customers_insert_input {
  address: String
  city: String
  company: String
  country: String
  email: String
  employee: employees_obj_rel_insert_input
  fax: String
  first_name: String
  id: Int
  invoices: invoices_arr_rel_insert_input
  last_name: String
  phone: String
  postal_code: String
  state: String
  support_rep_id: Int
}

# aggregate max on columns
type customers_max_fields {
  address: String
  city: String
  company: String
  country: String
  email: String
  fax: String
  first_name: String
  id: Int
  last_name: String
  phone: String
  postal_code: String
  state: String
  support_rep_id: Int
}

# order by max() on columns of table "customers"
input customers_max_order_by {
  address: order_by
  city: order_by
  company: order_by
  country: order_by
  email: order_by
  fax: order_by
  first_name: order_by
  id: order_by
  last_name: order_by
  phone: order_by
  postal_code: order_by
  state: order_by
  support_rep_id: order_by
}

# aggregate min on columns
type customers_min_fields {
  address: String
  city: String
  company: String
  country: String
  email: String
  fax: String
  first_name: String
  id: Int
  last_name: String
  phone: String
  postal_code: String
  state: String
  support_rep_id: Int
}

# order by min() on columns of table "customers"
input customers_min_order_by {
  address: order_by
  city: order_by
  company: order_by
  country: order_by
  email: order_by
  fax: order_by
  first_name: order_by
  id: order_by
  last_name: order_by
  phone: order_by
  postal_code: order_by
  state: order_by
  support_rep_id: order_by
}

# response of any mutation on the table "customers"
type customers_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [customers!]!
}

# input type for inserting object relation for remote table "customers"
input customers_obj_rel_insert_input {
  data: customers_insert_input!
  on_conflict: customers_on_conflict
}

# on conflict condition type for table "customers"
input customers_on_conflict {
  constraint: customers_constraint!
  update_columns: [customers_update_column!]!
  where: customers_bool_exp
}

# ordering options when selecting data from "customers"
input customers_order_by {
  address: order_by
  city: order_by
  company: order_by
  country: order_by
  email: order_by
  employee: employees_order_by
  fax: order_by
  first_name: order_by
  id: order_by
  invoices_aggregate: invoices_aggregate_order_by
  last_name: order_by
  phone: order_by
  postal_code: order_by
  state: order_by
  support_rep_id: order_by
}

# primary key columns input for table: "customers"
input customers_pk_columns_input {
  id: Int!
}

# select columns of table "customers"
enum customers_select_column {
  # column name
  address

  # column name
  city

  # column name
  company

  # column name
  country

  # column name
  email

  # column name
  fax

  # column name
  first_name

  # column name
  id

  # column name
  last_name

  # column name
  phone

  # column name
  postal_code

  # column name
  state

  # column name
  support_rep_id
}

# input type for updating data in table "customers"
input customers_set_input {
  address: String
  city: String
  company: String
  country: String
  email: String
  fax: String
  first_name: String
  id: Int
  last_name: String
  phone: String
  postal_code: String
  state: String
  support_rep_id: Int
}

# aggregate stddev on columns
type customers_stddev_fields {
  id: Float
  support_rep_id: Float
}

# order by stddev() on columns of table "customers"
input customers_stddev_order_by {
  id: order_by
  support_rep_id: order_by
}

# aggregate stddev_pop on columns
type customers_stddev_pop_fields {
  id: Float
  support_rep_id: Float
}

# order by stddev_pop() on columns of table "customers"
input customers_stddev_pop_order_by {
  id: order_by
  support_rep_id: order_by
}

# aggregate stddev_samp on columns
type customers_stddev_samp_fields {
  id: Float
  support_rep_id: Float
}

# order by stddev_samp() on columns of table "customers"
input customers_stddev_samp_order_by {
  id: order_by
  support_rep_id: order_by
}

# aggregate sum on columns
type customers_sum_fields {
  id: Int
  support_rep_id: Int
}

# order by sum() on columns of table "customers"
input customers_sum_order_by {
  id: order_by
  support_rep_id: order_by
}

# update columns of table "customers"
enum customers_update_column {
  # column name
  address

  # column name
  city

  # column name
  company

  # column name
  country

  # column name
  email

  # column name
  fax

  # column name
  first_name

  # column name
  id

  # column name
  last_name

  # column name
  phone

  # column name
  postal_code

  # column name
  state

  # column name
  support_rep_id
}

# aggregate var_pop on columns
type customers_var_pop_fields {
  id: Float
  support_rep_id: Float
}

# order by var_pop() on columns of table "customers"
input customers_var_pop_order_by {
  id: order_by
  support_rep_id: order_by
}

# aggregate var_samp on columns
type customers_var_samp_fields {
  id: Float
  support_rep_id: Float
}

# order by var_samp() on columns of table "customers"
input customers_var_samp_order_by {
  id: order_by
  support_rep_id: order_by
}

# aggregate variance on columns
type customers_variance_fields {
  id: Float
  support_rep_id: Float
}

# order by variance() on columns of table "customers"
input customers_variance_order_by {
  id: order_by
  support_rep_id: order_by
}

# columns and relationships of "employees"
type employees {
  address: String
  birth_date: timestamp
  city: String
  country: String

  # An array relationship
  customers(
    # distinct select on columns
    distinct_on: [customers_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [customers_order_by!]

    # filter the rows returned
    where: customers_bool_exp
  ): [customers!]!

  # An aggregated array relationship
  customers_aggregate(
    # distinct select on columns
    distinct_on: [customers_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [customers_order_by!]

    # filter the rows returned
    where: customers_bool_exp
  ): customers_aggregate!
  email: String

  # An object relationship
  employee: employees

  # An array relationship
  employees(
    # distinct select on columns
    distinct_on: [employees_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [employees_order_by!]

    # filter the rows returned
    where: employees_bool_exp
  ): [employees!]!

  # An aggregated array relationship
  employees_aggregate(
    # distinct select on columns
    distinct_on: [employees_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [employees_order_by!]

    # filter the rows returned
    where: employees_bool_exp
  ): employees_aggregate!
  fax: String
  first_name: String!
  hire_date: timestamp
  id: Int!
  last_name: String!
  phone: String
  postal_code: String
  reports_to: Int
  state: String
  title: String
}

# aggregated selection of "employees"
type employees_aggregate {
  aggregate: employees_aggregate_fields
  nodes: [employees!]!
}

# aggregate fields of "employees"
type employees_aggregate_fields {
  avg: employees_avg_fields
  count(columns: [employees_select_column!], distinct: Boolean): Int
  max: employees_max_fields
  min: employees_min_fields
  stddev: employees_stddev_fields
  stddev_pop: employees_stddev_pop_fields
  stddev_samp: employees_stddev_samp_fields
  sum: employees_sum_fields
  var_pop: employees_var_pop_fields
  var_samp: employees_var_samp_fields
  variance: employees_variance_fields
}

# order by aggregate values of table "employees"
input employees_aggregate_order_by {
  avg: employees_avg_order_by
  count: order_by
  max: employees_max_order_by
  min: employees_min_order_by
  stddev: employees_stddev_order_by
  stddev_pop: employees_stddev_pop_order_by
  stddev_samp: employees_stddev_samp_order_by
  sum: employees_sum_order_by
  var_pop: employees_var_pop_order_by
  var_samp: employees_var_samp_order_by
  variance: employees_variance_order_by
}

# input type for inserting array relation for remote table "employees"
input employees_arr_rel_insert_input {
  data: [employees_insert_input!]!
  on_conflict: employees_on_conflict
}

# aggregate avg on columns
type employees_avg_fields {
  id: Float
  reports_to: Float
}

# order by avg() on columns of table "employees"
input employees_avg_order_by {
  id: order_by
  reports_to: order_by
}

# Boolean expression to filter rows from the table "employees". All fields are combined with a logical 'AND'.
input employees_bool_exp {
  _and: [employees_bool_exp]
  _not: employees_bool_exp
  _or: [employees_bool_exp]
  address: String_comparison_exp
  birth_date: timestamp_comparison_exp
  city: String_comparison_exp
  country: String_comparison_exp
  customers: customers_bool_exp
  email: String_comparison_exp
  employee: employees_bool_exp
  employees: employees_bool_exp
  fax: String_comparison_exp
  first_name: String_comparison_exp
  hire_date: timestamp_comparison_exp
  id: Int_comparison_exp
  last_name: String_comparison_exp
  phone: String_comparison_exp
  postal_code: String_comparison_exp
  reports_to: Int_comparison_exp
  state: String_comparison_exp
  title: String_comparison_exp
}

# unique or primary key constraints on table "employees"
enum employees_constraint {
  # unique or primary key constraint
  pk_employees
}

# input type for incrementing integer column in table "employees"
input employees_inc_input {
  id: Int
  reports_to: Int
}

# input type for inserting data into table "employees"
input employees_insert_input {
  address: String
  birth_date: timestamp
  city: String
  country: String
  customers: customers_arr_rel_insert_input
  email: String
  employee: employees_obj_rel_insert_input
  employees: employees_arr_rel_insert_input
  fax: String
  first_name: String
  hire_date: timestamp
  id: Int
  last_name: String
  phone: String
  postal_code: String
  reports_to: Int
  state: String
  title: String
}

# aggregate max on columns
type employees_max_fields {
  address: String
  birth_date: timestamp
  city: String
  country: String
  email: String
  fax: String
  first_name: String
  hire_date: timestamp
  id: Int
  last_name: String
  phone: String
  postal_code: String
  reports_to: Int
  state: String
  title: String
}

# order by max() on columns of table "employees"
input employees_max_order_by {
  address: order_by
  birth_date: order_by
  city: order_by
  country: order_by
  email: order_by
  fax: order_by
  first_name: order_by
  hire_date: order_by
  id: order_by
  last_name: order_by
  phone: order_by
  postal_code: order_by
  reports_to: order_by
  state: order_by
  title: order_by
}

# aggregate min on columns
type employees_min_fields {
  address: String
  birth_date: timestamp
  city: String
  country: String
  email: String
  fax: String
  first_name: String
  hire_date: timestamp
  id: Int
  last_name: String
  phone: String
  postal_code: String
  reports_to: Int
  state: String
  title: String
}

# order by min() on columns of table "employees"
input employees_min_order_by {
  address: order_by
  birth_date: order_by
  city: order_by
  country: order_by
  email: order_by
  fax: order_by
  first_name: order_by
  hire_date: order_by
  id: order_by
  last_name: order_by
  phone: order_by
  postal_code: order_by
  reports_to: order_by
  state: order_by
  title: order_by
}

# response of any mutation on the table "employees"
type employees_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [employees!]!
}

# input type for inserting object relation for remote table "employees"
input employees_obj_rel_insert_input {
  data: employees_insert_input!
  on_conflict: employees_on_conflict
}

# on conflict condition type for table "employees"
input employees_on_conflict {
  constraint: employees_constraint!
  update_columns: [employees_update_column!]!
  where: employees_bool_exp
}

# ordering options when selecting data from "employees"
input employees_order_by {
  address: order_by
  birth_date: order_by
  city: order_by
  country: order_by
  customers_aggregate: customers_aggregate_order_by
  email: order_by
  employee: employees_order_by
  employees_aggregate: employees_aggregate_order_by
  fax: order_by
  first_name: order_by
  hire_date: order_by
  id: order_by
  last_name: order_by
  phone: order_by
  postal_code: order_by
  reports_to: order_by
  state: order_by
  title: order_by
}

# primary key columns input for table: "employees"
input employees_pk_columns_input {
  id: Int!
}

# select columns of table "employees"
enum employees_select_column {
  # column name
  address

  # column name
  birth_date

  # column name
  city

  # column name
  country

  # column name
  email

  # column name
  fax

  # column name
  first_name

  # column name
  hire_date

  # column name
  id

  # column name
  last_name

  # column name
  phone

  # column name
  postal_code

  # column name
  reports_to

  # column name
  state

  # column name
  title
}

# input type for updating data in table "employees"
input employees_set_input {
  address: String
  birth_date: timestamp
  city: String
  country: String
  email: String
  fax: String
  first_name: String
  hire_date: timestamp
  id: Int
  last_name: String
  phone: String
  postal_code: String
  reports_to: Int
  state: String
  title: String
}

# aggregate stddev on columns
type employees_stddev_fields {
  id: Float
  reports_to: Float
}

# order by stddev() on columns of table "employees"
input employees_stddev_order_by {
  id: order_by
  reports_to: order_by
}

# aggregate stddev_pop on columns
type employees_stddev_pop_fields {
  id: Float
  reports_to: Float
}

# order by stddev_pop() on columns of table "employees"
input employees_stddev_pop_order_by {
  id: order_by
  reports_to: order_by
}

# aggregate stddev_samp on columns
type employees_stddev_samp_fields {
  id: Float
  reports_to: Float
}

# order by stddev_samp() on columns of table "employees"
input employees_stddev_samp_order_by {
  id: order_by
  reports_to: order_by
}

# aggregate sum on columns
type employees_sum_fields {
  id: Int
  reports_to: Int
}

# order by sum() on columns of table "employees"
input employees_sum_order_by {
  id: order_by
  reports_to: order_by
}

# update columns of table "employees"
enum employees_update_column {
  # column name
  address

  # column name
  birth_date

  # column name
  city

  # column name
  country

  # column name
  email

  # column name
  fax

  # column name
  first_name

  # column name
  hire_date

  # column name
  id

  # column name
  last_name

  # column name
  phone

  # column name
  postal_code

  # column name
  reports_to

  # column name
  state

  # column name
  title
}

# aggregate var_pop on columns
type employees_var_pop_fields {
  id: Float
  reports_to: Float
}

# order by var_pop() on columns of table "employees"
input employees_var_pop_order_by {
  id: order_by
  reports_to: order_by
}

# aggregate var_samp on columns
type employees_var_samp_fields {
  id: Float
  reports_to: Float
}

# order by var_samp() on columns of table "employees"
input employees_var_samp_order_by {
  id: order_by
  reports_to: order_by
}

# aggregate variance on columns
type employees_variance_fields {
  id: Float
  reports_to: Float
}

# order by variance() on columns of table "employees"
input employees_variance_order_by {
  id: order_by
  reports_to: order_by
}

# columns and relationships of "events"
type events {
  connection_id: Int!
  event_data(
    # JSON select path
    path: String
  ): jsonb!
  event_number: Int!
  event_time: timestamptz!
  is_error: Boolean!
  label: String!
  latency: Int
  operation_id: Int!
}

# aggregated selection of "events"
type events_aggregate {
  aggregate: events_aggregate_fields
  nodes: [events!]!
}

# aggregate fields of "events"
type events_aggregate_fields {
  avg: events_avg_fields
  count(columns: [events_select_column!], distinct: Boolean): Int
  max: events_max_fields
  min: events_min_fields
  stddev: events_stddev_fields
  stddev_pop: events_stddev_pop_fields
  stddev_samp: events_stddev_samp_fields
  sum: events_sum_fields
  var_pop: events_var_pop_fields
  var_samp: events_var_samp_fields
  variance: events_variance_fields
}

# order by aggregate values of table "events"
input events_aggregate_order_by {
  avg: events_avg_order_by
  count: order_by
  max: events_max_order_by
  min: events_min_order_by
  stddev: events_stddev_order_by
  stddev_pop: events_stddev_pop_order_by
  stddev_samp: events_stddev_samp_order_by
  sum: events_sum_order_by
  var_pop: events_var_pop_order_by
  var_samp: events_var_samp_order_by
  variance: events_variance_order_by
}

# append existing jsonb value of filtered columns with new jsonb value
input events_append_input {
  event_data: jsonb
}

# input type for inserting array relation for remote table "events"
input events_arr_rel_insert_input {
  data: [events_insert_input!]!
  on_conflict: events_on_conflict
}

# aggregate avg on columns
type events_avg_fields {
  connection_id: Float
  event_number: Float
  latency: Float
  operation_id: Float
}

# order by avg() on columns of table "events"
input events_avg_order_by {
  connection_id: order_by
  event_number: order_by
  latency: order_by
  operation_id: order_by
}

# Boolean expression to filter rows from the table "events". All fields are combined with a logical 'AND'.
input events_bool_exp {
  _and: [events_bool_exp]
  _not: events_bool_exp
  _or: [events_bool_exp]
  connection_id: Int_comparison_exp
  event_data: jsonb_comparison_exp
  event_number: Int_comparison_exp
  event_time: timestamptz_comparison_exp
  is_error: Boolean_comparison_exp
  label: String_comparison_exp
  latency: Int_comparison_exp
  operation_id: Int_comparison_exp
}

# unique or primary key constraints on table "events"
enum events_constraint {
  # unique or primary key constraint
  events_label_connection_id_operation_id_event_number_unique
}

# delete the field or element with specified path (for JSON arrays, negative integers count from the end)
input events_delete_at_path_input {
  event_data: [String]
}

# delete the array element with specified index (negative integers count from the
# end). throws an error if top level container is not an array
input events_delete_elem_input {
  event_data: Int
}

# delete key/value pair or string element. key/value pairs are matched based on their key value
input events_delete_key_input {
  event_data: String
}

# input type for incrementing integer column in table "events"
input events_inc_input {
  connection_id: Int
  event_number: Int
  latency: Int
  operation_id: Int
}

# input type for inserting data into table "events"
input events_insert_input {
  connection_id: Int
  event_data: jsonb
  event_number: Int
  event_time: timestamptz
  is_error: Boolean
  label: String
  latency: Int
  operation_id: Int
}

# aggregate max on columns
type events_max_fields {
  connection_id: Int
  event_number: Int
  event_time: timestamptz
  label: String
  latency: Int
  operation_id: Int
}

# order by max() on columns of table "events"
input events_max_order_by {
  connection_id: order_by
  event_number: order_by
  event_time: order_by
  label: order_by
  latency: order_by
  operation_id: order_by
}

# aggregate min on columns
type events_min_fields {
  connection_id: Int
  event_number: Int
  event_time: timestamptz
  label: String
  latency: Int
  operation_id: Int
}

# order by min() on columns of table "events"
input events_min_order_by {
  connection_id: order_by
  event_number: order_by
  event_time: order_by
  label: order_by
  latency: order_by
  operation_id: order_by
}

# response of any mutation on the table "events"
type events_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [events!]!
}

# input type for inserting object relation for remote table "events"
input events_obj_rel_insert_input {
  data: events_insert_input!
  on_conflict: events_on_conflict
}

# on conflict condition type for table "events"
input events_on_conflict {
  constraint: events_constraint!
  update_columns: [events_update_column!]!
  where: events_bool_exp
}

# ordering options when selecting data from "events"
input events_order_by {
  connection_id: order_by
  event_data: order_by
  event_number: order_by
  event_time: order_by
  is_error: order_by
  label: order_by
  latency: order_by
  operation_id: order_by
}

# prepend existing jsonb value of filtered columns with new jsonb value
input events_prepend_input {
  event_data: jsonb
}

# select columns of table "events"
enum events_select_column {
  # column name
  connection_id

  # column name
  event_data

  # column name
  event_number

  # column name
  event_time

  # column name
  is_error

  # column name
  label

  # column name
  latency

  # column name
  operation_id
}

# input type for updating data in table "events"
input events_set_input {
  connection_id: Int
  event_data: jsonb
  event_number: Int
  event_time: timestamptz
  is_error: Boolean
  label: String
  latency: Int
  operation_id: Int
}

# aggregate stddev on columns
type events_stddev_fields {
  connection_id: Float
  event_number: Float
  latency: Float
  operation_id: Float
}

# order by stddev() on columns of table "events"
input events_stddev_order_by {
  connection_id: order_by
  event_number: order_by
  latency: order_by
  operation_id: order_by
}

# aggregate stddev_pop on columns
type events_stddev_pop_fields {
  connection_id: Float
  event_number: Float
  latency: Float
  operation_id: Float
}

# order by stddev_pop() on columns of table "events"
input events_stddev_pop_order_by {
  connection_id: order_by
  event_number: order_by
  latency: order_by
  operation_id: order_by
}

# aggregate stddev_samp on columns
type events_stddev_samp_fields {
  connection_id: Float
  event_number: Float
  latency: Float
  operation_id: Float
}

# order by stddev_samp() on columns of table "events"
input events_stddev_samp_order_by {
  connection_id: order_by
  event_number: order_by
  latency: order_by
  operation_id: order_by
}

# aggregate sum on columns
type events_sum_fields {
  connection_id: Int
  event_number: Int
  latency: Int
  operation_id: Int
}

# order by sum() on columns of table "events"
input events_sum_order_by {
  connection_id: order_by
  event_number: order_by
  latency: order_by
  operation_id: order_by
}

# update columns of table "events"
enum events_update_column {
  # column name
  connection_id

  # column name
  event_data

  # column name
  event_number

  # column name
  event_time

  # column name
  is_error

  # column name
  label

  # column name
  latency

  # column name
  operation_id
}

# aggregate var_pop on columns
type events_var_pop_fields {
  connection_id: Float
  event_number: Float
  latency: Float
  operation_id: Float
}

# order by var_pop() on columns of table "events"
input events_var_pop_order_by {
  connection_id: order_by
  event_number: order_by
  latency: order_by
  operation_id: order_by
}

# aggregate var_samp on columns
type events_var_samp_fields {
  connection_id: Float
  event_number: Float
  latency: Float
  operation_id: Float
}

# order by var_samp() on columns of table "events"
input events_var_samp_order_by {
  connection_id: order_by
  event_number: order_by
  latency: order_by
  operation_id: order_by
}

# aggregate variance on columns
type events_variance_fields {
  connection_id: Float
  event_number: Float
  latency: Float
  operation_id: Float
}

# order by variance() on columns of table "events"
input events_variance_order_by {
  connection_id: order_by
  event_number: order_by
  latency: order_by
  operation_id: order_by
}

# columns and relationships of "film_actor"
type film_actor {
  actor_id: smallint!
  film_id: smallint!
  last_update: timestamp!
}

# aggregated selection of "film_actor"
type film_actor_aggregate {
  aggregate: film_actor_aggregate_fields
  nodes: [film_actor!]!
}

# aggregate fields of "film_actor"
type film_actor_aggregate_fields {
  avg: film_actor_avg_fields
  count(columns: [film_actor_select_column!], distinct: Boolean): Int
  max: film_actor_max_fields
  min: film_actor_min_fields
  stddev: film_actor_stddev_fields
  stddev_pop: film_actor_stddev_pop_fields
  stddev_samp: film_actor_stddev_samp_fields
  sum: film_actor_sum_fields
  var_pop: film_actor_var_pop_fields
  var_samp: film_actor_var_samp_fields
  variance: film_actor_variance_fields
}

# order by aggregate values of table "film_actor"
input film_actor_aggregate_order_by {
  avg: film_actor_avg_order_by
  count: order_by
  max: film_actor_max_order_by
  min: film_actor_min_order_by
  stddev: film_actor_stddev_order_by
  stddev_pop: film_actor_stddev_pop_order_by
  stddev_samp: film_actor_stddev_samp_order_by
  sum: film_actor_sum_order_by
  var_pop: film_actor_var_pop_order_by
  var_samp: film_actor_var_samp_order_by
  variance: film_actor_variance_order_by
}

# input type for inserting array relation for remote table "film_actor"
input film_actor_arr_rel_insert_input {
  data: [film_actor_insert_input!]!
  on_conflict: film_actor_on_conflict
}

# aggregate avg on columns
type film_actor_avg_fields {
  actor_id: Float
  film_id: Float
}

# order by avg() on columns of table "film_actor"
input film_actor_avg_order_by {
  actor_id: order_by
  film_id: order_by
}

# Boolean expression to filter rows from the table "film_actor". All fields are combined with a logical 'AND'.
input film_actor_bool_exp {
  _and: [film_actor_bool_exp]
  _not: film_actor_bool_exp
  _or: [film_actor_bool_exp]
  actor_id: smallint_comparison_exp
  film_id: smallint_comparison_exp
  last_update: timestamp_comparison_exp
}

# unique or primary key constraints on table "film_actor"
enum film_actor_constraint {
  # unique or primary key constraint
  film_actor_pkey
}

# input type for incrementing integer column in table "film_actor"
input film_actor_inc_input {
  actor_id: smallint
  film_id: smallint
}

# input type for inserting data into table "film_actor"
input film_actor_insert_input {
  actor_id: smallint
  film_id: smallint
  last_update: timestamp
}

# aggregate max on columns
type film_actor_max_fields {
  actor_id: smallint
  film_id: smallint
  last_update: timestamp
}

# order by max() on columns of table "film_actor"
input film_actor_max_order_by {
  actor_id: order_by
  film_id: order_by
  last_update: order_by
}

# aggregate min on columns
type film_actor_min_fields {
  actor_id: smallint
  film_id: smallint
  last_update: timestamp
}

# order by min() on columns of table "film_actor"
input film_actor_min_order_by {
  actor_id: order_by
  film_id: order_by
  last_update: order_by
}

# response of any mutation on the table "film_actor"
type film_actor_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [film_actor!]!
}

# input type for inserting object relation for remote table "film_actor"
input film_actor_obj_rel_insert_input {
  data: film_actor_insert_input!
  on_conflict: film_actor_on_conflict
}

# on conflict condition type for table "film_actor"
input film_actor_on_conflict {
  constraint: film_actor_constraint!
  update_columns: [film_actor_update_column!]!
  where: film_actor_bool_exp
}

# ordering options when selecting data from "film_actor"
input film_actor_order_by {
  actor_id: order_by
  film_id: order_by
  last_update: order_by
}

# primary key columns input for table: "film_actor"
input film_actor_pk_columns_input {
  actor_id: smallint!
  film_id: smallint!
}

# select columns of table "film_actor"
enum film_actor_select_column {
  # column name
  actor_id

  # column name
  film_id

  # column name
  last_update
}

# input type for updating data in table "film_actor"
input film_actor_set_input {
  actor_id: smallint
  film_id: smallint
  last_update: timestamp
}

# aggregate stddev on columns
type film_actor_stddev_fields {
  actor_id: Float
  film_id: Float
}

# order by stddev() on columns of table "film_actor"
input film_actor_stddev_order_by {
  actor_id: order_by
  film_id: order_by
}

# aggregate stddev_pop on columns
type film_actor_stddev_pop_fields {
  actor_id: Float
  film_id: Float
}

# order by stddev_pop() on columns of table "film_actor"
input film_actor_stddev_pop_order_by {
  actor_id: order_by
  film_id: order_by
}

# aggregate stddev_samp on columns
type film_actor_stddev_samp_fields {
  actor_id: Float
  film_id: Float
}

# order by stddev_samp() on columns of table "film_actor"
input film_actor_stddev_samp_order_by {
  actor_id: order_by
  film_id: order_by
}

# aggregate sum on columns
type film_actor_sum_fields {
  actor_id: smallint
  film_id: smallint
}

# order by sum() on columns of table "film_actor"
input film_actor_sum_order_by {
  actor_id: order_by
  film_id: order_by
}

# update columns of table "film_actor"
enum film_actor_update_column {
  # column name
  actor_id

  # column name
  film_id

  # column name
  last_update
}

# aggregate var_pop on columns
type film_actor_var_pop_fields {
  actor_id: Float
  film_id: Float
}

# order by var_pop() on columns of table "film_actor"
input film_actor_var_pop_order_by {
  actor_id: order_by
  film_id: order_by
}

# aggregate var_samp on columns
type film_actor_var_samp_fields {
  actor_id: Float
  film_id: Float
}

# order by var_samp() on columns of table "film_actor"
input film_actor_var_samp_order_by {
  actor_id: order_by
  film_id: order_by
}

# aggregate variance on columns
type film_actor_variance_fields {
  actor_id: Float
  film_id: Float
}

# order by variance() on columns of table "film_actor"
input film_actor_variance_order_by {
  actor_id: order_by
  film_id: order_by
}

# columns and relationships of "film_category"
type film_category {
  category_id: smallint!
  film_id: smallint!
  last_update: timestamp!
}

# aggregated selection of "film_category"
type film_category_aggregate {
  aggregate: film_category_aggregate_fields
  nodes: [film_category!]!
}

# aggregate fields of "film_category"
type film_category_aggregate_fields {
  avg: film_category_avg_fields
  count(columns: [film_category_select_column!], distinct: Boolean): Int
  max: film_category_max_fields
  min: film_category_min_fields
  stddev: film_category_stddev_fields
  stddev_pop: film_category_stddev_pop_fields
  stddev_samp: film_category_stddev_samp_fields
  sum: film_category_sum_fields
  var_pop: film_category_var_pop_fields
  var_samp: film_category_var_samp_fields
  variance: film_category_variance_fields
}

# order by aggregate values of table "film_category"
input film_category_aggregate_order_by {
  avg: film_category_avg_order_by
  count: order_by
  max: film_category_max_order_by
  min: film_category_min_order_by
  stddev: film_category_stddev_order_by
  stddev_pop: film_category_stddev_pop_order_by
  stddev_samp: film_category_stddev_samp_order_by
  sum: film_category_sum_order_by
  var_pop: film_category_var_pop_order_by
  var_samp: film_category_var_samp_order_by
  variance: film_category_variance_order_by
}

# input type for inserting array relation for remote table "film_category"
input film_category_arr_rel_insert_input {
  data: [film_category_insert_input!]!
}

# aggregate avg on columns
type film_category_avg_fields {
  category_id: Float
  film_id: Float
}

# order by avg() on columns of table "film_category"
input film_category_avg_order_by {
  category_id: order_by
  film_id: order_by
}

# Boolean expression to filter rows from the table "film_category". All fields are combined with a logical 'AND'.
input film_category_bool_exp {
  _and: [film_category_bool_exp]
  _not: film_category_bool_exp
  _or: [film_category_bool_exp]
  category_id: smallint_comparison_exp
  film_id: smallint_comparison_exp
  last_update: timestamp_comparison_exp
}

# input type for incrementing integer column in table "film_category"
input film_category_inc_input {
  category_id: smallint
  film_id: smallint
}

# input type for inserting data into table "film_category"
input film_category_insert_input {
  category_id: smallint
  film_id: smallint
  last_update: timestamp
}

# aggregate max on columns
type film_category_max_fields {
  category_id: smallint
  film_id: smallint
  last_update: timestamp
}

# order by max() on columns of table "film_category"
input film_category_max_order_by {
  category_id: order_by
  film_id: order_by
  last_update: order_by
}

# aggregate min on columns
type film_category_min_fields {
  category_id: smallint
  film_id: smallint
  last_update: timestamp
}

# order by min() on columns of table "film_category"
input film_category_min_order_by {
  category_id: order_by
  film_id: order_by
  last_update: order_by
}

# response of any mutation on the table "film_category"
type film_category_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [film_category!]!
}

# input type for inserting object relation for remote table "film_category"
input film_category_obj_rel_insert_input {
  data: film_category_insert_input!
}

# ordering options when selecting data from "film_category"
input film_category_order_by {
  category_id: order_by
  film_id: order_by
  last_update: order_by
}

# select columns of table "film_category"
enum film_category_select_column {
  # column name
  category_id

  # column name
  film_id

  # column name
  last_update
}

# input type for updating data in table "film_category"
input film_category_set_input {
  category_id: smallint
  film_id: smallint
  last_update: timestamp
}

# aggregate stddev on columns
type film_category_stddev_fields {
  category_id: Float
  film_id: Float
}

# order by stddev() on columns of table "film_category"
input film_category_stddev_order_by {
  category_id: order_by
  film_id: order_by
}

# aggregate stddev_pop on columns
type film_category_stddev_pop_fields {
  category_id: Float
  film_id: Float
}

# order by stddev_pop() on columns of table "film_category"
input film_category_stddev_pop_order_by {
  category_id: order_by
  film_id: order_by
}

# aggregate stddev_samp on columns
type film_category_stddev_samp_fields {
  category_id: Float
  film_id: Float
}

# order by stddev_samp() on columns of table "film_category"
input film_category_stddev_samp_order_by {
  category_id: order_by
  film_id: order_by
}

# aggregate sum on columns
type film_category_sum_fields {
  category_id: smallint
  film_id: smallint
}

# order by sum() on columns of table "film_category"
input film_category_sum_order_by {
  category_id: order_by
  film_id: order_by
}

# aggregate var_pop on columns
type film_category_var_pop_fields {
  category_id: Float
  film_id: Float
}

# order by var_pop() on columns of table "film_category"
input film_category_var_pop_order_by {
  category_id: order_by
  film_id: order_by
}

# aggregate var_samp on columns
type film_category_var_samp_fields {
  category_id: Float
  film_id: Float
}

# order by var_samp() on columns of table "film_category"
input film_category_var_samp_order_by {
  category_id: order_by
  film_id: order_by
}

# aggregate variance on columns
type film_category_variance_fields {
  category_id: Float
  film_id: Float
}

# order by variance() on columns of table "film_category"
input film_category_variance_order_by {
  category_id: order_by
  film_id: order_by
}

# columns and relationships of "films"
type films {
  description: String
  fulltext: tsvector!
  id: Int!
  language_id: smallint!
  last_update: timestamp!
  length: smallint
  rating: String
  release_year: Int
  rental_duration: smallint!
  rental_rate: numeric!
  replacement_cost: numeric!
  special_features: _text
  title: String!
}

# aggregated selection of "films"
type films_aggregate {
  aggregate: films_aggregate_fields
  nodes: [films!]!
}

# aggregate fields of "films"
type films_aggregate_fields {
  avg: films_avg_fields
  count(columns: [films_select_column!], distinct: Boolean): Int
  max: films_max_fields
  min: films_min_fields
  stddev: films_stddev_fields
  stddev_pop: films_stddev_pop_fields
  stddev_samp: films_stddev_samp_fields
  sum: films_sum_fields
  var_pop: films_var_pop_fields
  var_samp: films_var_samp_fields
  variance: films_variance_fields
}

# order by aggregate values of table "films"
input films_aggregate_order_by {
  avg: films_avg_order_by
  count: order_by
  max: films_max_order_by
  min: films_min_order_by
  stddev: films_stddev_order_by
  stddev_pop: films_stddev_pop_order_by
  stddev_samp: films_stddev_samp_order_by
  sum: films_sum_order_by
  var_pop: films_var_pop_order_by
  var_samp: films_var_samp_order_by
  variance: films_variance_order_by
}

# input type for inserting array relation for remote table "films"
input films_arr_rel_insert_input {
  data: [films_insert_input!]!
  on_conflict: films_on_conflict
}

# aggregate avg on columns
type films_avg_fields {
  id: Float
  language_id: Float
  length: Float
  release_year: Float
  rental_duration: Float
  rental_rate: Float
  replacement_cost: Float
}

# order by avg() on columns of table "films"
input films_avg_order_by {
  id: order_by
  language_id: order_by
  length: order_by
  release_year: order_by
  rental_duration: order_by
  rental_rate: order_by
  replacement_cost: order_by
}

# Boolean expression to filter rows from the table "films". All fields are combined with a logical 'AND'.
input films_bool_exp {
  _and: [films_bool_exp]
  _not: films_bool_exp
  _or: [films_bool_exp]
  description: String_comparison_exp
  fulltext: tsvector_comparison_exp
  id: Int_comparison_exp
  language_id: smallint_comparison_exp
  last_update: timestamp_comparison_exp
  length: smallint_comparison_exp
  rating: String_comparison_exp
  release_year: Int_comparison_exp
  rental_duration: smallint_comparison_exp
  rental_rate: numeric_comparison_exp
  replacement_cost: numeric_comparison_exp
  special_features: _text_comparison_exp
  title: String_comparison_exp
}

# unique or primary key constraints on table "films"
enum films_constraint {
  # unique or primary key constraint
  films_pkey
}

# input type for incrementing integer column in table "films"
input films_inc_input {
  id: Int
  language_id: smallint
  length: smallint
  release_year: Int
  rental_duration: smallint
  rental_rate: numeric
  replacement_cost: numeric
}

# input type for inserting data into table "films"
input films_insert_input {
  description: String
  fulltext: tsvector
  id: Int
  language_id: smallint
  last_update: timestamp
  length: smallint
  rating: String
  release_year: Int
  rental_duration: smallint
  rental_rate: numeric
  replacement_cost: numeric
  special_features: _text
  title: String
}

# aggregate max on columns
type films_max_fields {
  description: String
  id: Int
  language_id: smallint
  last_update: timestamp
  length: smallint
  rating: String
  release_year: Int
  rental_duration: smallint
  rental_rate: numeric
  replacement_cost: numeric
  title: String
}

# order by max() on columns of table "films"
input films_max_order_by {
  description: order_by
  id: order_by
  language_id: order_by
  last_update: order_by
  length: order_by
  rating: order_by
  release_year: order_by
  rental_duration: order_by
  rental_rate: order_by
  replacement_cost: order_by
  title: order_by
}

# aggregate min on columns
type films_min_fields {
  description: String
  id: Int
  language_id: smallint
  last_update: timestamp
  length: smallint
  rating: String
  release_year: Int
  rental_duration: smallint
  rental_rate: numeric
  replacement_cost: numeric
  title: String
}

# order by min() on columns of table "films"
input films_min_order_by {
  description: order_by
  id: order_by
  language_id: order_by
  last_update: order_by
  length: order_by
  rating: order_by
  release_year: order_by
  rental_duration: order_by
  rental_rate: order_by
  replacement_cost: order_by
  title: order_by
}

# response of any mutation on the table "films"
type films_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [films!]!
}

# input type for inserting object relation for remote table "films"
input films_obj_rel_insert_input {
  data: films_insert_input!
  on_conflict: films_on_conflict
}

# on conflict condition type for table "films"
input films_on_conflict {
  constraint: films_constraint!
  update_columns: [films_update_column!]!
  where: films_bool_exp
}

# ordering options when selecting data from "films"
input films_order_by {
  description: order_by
  fulltext: order_by
  id: order_by
  language_id: order_by
  last_update: order_by
  length: order_by
  rating: order_by
  release_year: order_by
  rental_duration: order_by
  rental_rate: order_by
  replacement_cost: order_by
  special_features: order_by
  title: order_by
}

# primary key columns input for table: "films"
input films_pk_columns_input {
  id: Int!
}

# select columns of table "films"
enum films_select_column {
  # column name
  description

  # column name
  fulltext

  # column name
  id

  # column name
  language_id

  # column name
  last_update

  # column name
  length

  # column name
  rating

  # column name
  release_year

  # column name
  rental_duration

  # column name
  rental_rate

  # column name
  replacement_cost

  # column name
  special_features

  # column name
  title
}

# input type for updating data in table "films"
input films_set_input {
  description: String
  fulltext: tsvector
  id: Int
  language_id: smallint
  last_update: timestamp
  length: smallint
  rating: String
  release_year: Int
  rental_duration: smallint
  rental_rate: numeric
  replacement_cost: numeric
  special_features: _text
  title: String
}

# aggregate stddev on columns
type films_stddev_fields {
  id: Float
  language_id: Float
  length: Float
  release_year: Float
  rental_duration: Float
  rental_rate: Float
  replacement_cost: Float
}

# order by stddev() on columns of table "films"
input films_stddev_order_by {
  id: order_by
  language_id: order_by
  length: order_by
  release_year: order_by
  rental_duration: order_by
  rental_rate: order_by
  replacement_cost: order_by
}

# aggregate stddev_pop on columns
type films_stddev_pop_fields {
  id: Float
  language_id: Float
  length: Float
  release_year: Float
  rental_duration: Float
  rental_rate: Float
  replacement_cost: Float
}

# order by stddev_pop() on columns of table "films"
input films_stddev_pop_order_by {
  id: order_by
  language_id: order_by
  length: order_by
  release_year: order_by
  rental_duration: order_by
  rental_rate: order_by
  replacement_cost: order_by
}

# aggregate stddev_samp on columns
type films_stddev_samp_fields {
  id: Float
  language_id: Float
  length: Float
  release_year: Float
  rental_duration: Float
  rental_rate: Float
  replacement_cost: Float
}

# order by stddev_samp() on columns of table "films"
input films_stddev_samp_order_by {
  id: order_by
  language_id: order_by
  length: order_by
  release_year: order_by
  rental_duration: order_by
  rental_rate: order_by
  replacement_cost: order_by
}

# aggregate sum on columns
type films_sum_fields {
  id: Int
  language_id: smallint
  length: smallint
  release_year: Int
  rental_duration: smallint
  rental_rate: numeric
  replacement_cost: numeric
}

# order by sum() on columns of table "films"
input films_sum_order_by {
  id: order_by
  language_id: order_by
  length: order_by
  release_year: order_by
  rental_duration: order_by
  rental_rate: order_by
  replacement_cost: order_by
}

# update columns of table "films"
enum films_update_column {
  # column name
  description

  # column name
  fulltext

  # column name
  id

  # column name
  language_id

  # column name
  last_update

  # column name
  length

  # column name
  rating

  # column name
  release_year

  # column name
  rental_duration

  # column name
  rental_rate

  # column name
  replacement_cost

  # column name
  special_features

  # column name
  title
}

# aggregate var_pop on columns
type films_var_pop_fields {
  id: Float
  language_id: Float
  length: Float
  release_year: Float
  rental_duration: Float
  rental_rate: Float
  replacement_cost: Float
}

# order by var_pop() on columns of table "films"
input films_var_pop_order_by {
  id: order_by
  language_id: order_by
  length: order_by
  release_year: order_by
  rental_duration: order_by
  rental_rate: order_by
  replacement_cost: order_by
}

# aggregate var_samp on columns
type films_var_samp_fields {
  id: Float
  language_id: Float
  length: Float
  release_year: Float
  rental_duration: Float
  rental_rate: Float
  replacement_cost: Float
}

# order by var_samp() on columns of table "films"
input films_var_samp_order_by {
  id: order_by
  language_id: order_by
  length: order_by
  release_year: order_by
  rental_duration: order_by
  rental_rate: order_by
  replacement_cost: order_by
}

# aggregate variance on columns
type films_variance_fields {
  id: Float
  language_id: Float
  length: Float
  release_year: Float
  rental_duration: Float
  rental_rate: Float
  replacement_cost: Float
}

# order by variance() on columns of table "films"
input films_variance_order_by {
  id: order_by
  language_id: order_by
  length: order_by
  release_year: order_by
  rental_duration: order_by
  rental_rate: order_by
  replacement_cost: order_by
}

# columns and relationships of "genres"
type genres {
  id: Int!
  name: String

  # An array relationship
  tracks(
    # distinct select on columns
    distinct_on: [tracks_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [tracks_order_by!]

    # filter the rows returned
    where: tracks_bool_exp
  ): [tracks!]!

  # An aggregated array relationship
  tracks_aggregate(
    # distinct select on columns
    distinct_on: [tracks_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [tracks_order_by!]

    # filter the rows returned
    where: tracks_bool_exp
  ): tracks_aggregate!
}

# aggregated selection of "genres"
type genres_aggregate {
  aggregate: genres_aggregate_fields
  nodes: [genres!]!
}

# aggregate fields of "genres"
type genres_aggregate_fields {
  avg: genres_avg_fields
  count(columns: [genres_select_column!], distinct: Boolean): Int
  max: genres_max_fields
  min: genres_min_fields
  stddev: genres_stddev_fields
  stddev_pop: genres_stddev_pop_fields
  stddev_samp: genres_stddev_samp_fields
  sum: genres_sum_fields
  var_pop: genres_var_pop_fields
  var_samp: genres_var_samp_fields
  variance: genres_variance_fields
}

# order by aggregate values of table "genres"
input genres_aggregate_order_by {
  avg: genres_avg_order_by
  count: order_by
  max: genres_max_order_by
  min: genres_min_order_by
  stddev: genres_stddev_order_by
  stddev_pop: genres_stddev_pop_order_by
  stddev_samp: genres_stddev_samp_order_by
  sum: genres_sum_order_by
  var_pop: genres_var_pop_order_by
  var_samp: genres_var_samp_order_by
  variance: genres_variance_order_by
}

# input type for inserting array relation for remote table "genres"
input genres_arr_rel_insert_input {
  data: [genres_insert_input!]!
  on_conflict: genres_on_conflict
}

# aggregate avg on columns
type genres_avg_fields {
  id: Float
}

# order by avg() on columns of table "genres"
input genres_avg_order_by {
  id: order_by
}

# Boolean expression to filter rows from the table "genres". All fields are combined with a logical 'AND'.
input genres_bool_exp {
  _and: [genres_bool_exp]
  _not: genres_bool_exp
  _or: [genres_bool_exp]
  id: Int_comparison_exp
  name: String_comparison_exp
  tracks: tracks_bool_exp
}

# unique or primary key constraints on table "genres"
enum genres_constraint {
  # unique or primary key constraint
  pk_genres
}

# input type for incrementing integer column in table "genres"
input genres_inc_input {
  id: Int
}

# input type for inserting data into table "genres"
input genres_insert_input {
  id: Int
  name: String
  tracks: tracks_arr_rel_insert_input
}

# aggregate max on columns
type genres_max_fields {
  id: Int
  name: String
}

# order by max() on columns of table "genres"
input genres_max_order_by {
  id: order_by
  name: order_by
}

# aggregate min on columns
type genres_min_fields {
  id: Int
  name: String
}

# order by min() on columns of table "genres"
input genres_min_order_by {
  id: order_by
  name: order_by
}

# response of any mutation on the table "genres"
type genres_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [genres!]!
}

# input type for inserting object relation for remote table "genres"
input genres_obj_rel_insert_input {
  data: genres_insert_input!
  on_conflict: genres_on_conflict
}

# on conflict condition type for table "genres"
input genres_on_conflict {
  constraint: genres_constraint!
  update_columns: [genres_update_column!]!
  where: genres_bool_exp
}

# ordering options when selecting data from "genres"
input genres_order_by {
  id: order_by
  name: order_by
  tracks_aggregate: tracks_aggregate_order_by
}

# primary key columns input for table: "genres"
input genres_pk_columns_input {
  id: Int!
}

# select columns of table "genres"
enum genres_select_column {
  # column name
  id

  # column name
  name
}

# input type for updating data in table "genres"
input genres_set_input {
  id: Int
  name: String
}

# aggregate stddev on columns
type genres_stddev_fields {
  id: Float
}

# order by stddev() on columns of table "genres"
input genres_stddev_order_by {
  id: order_by
}

# aggregate stddev_pop on columns
type genres_stddev_pop_fields {
  id: Float
}

# order by stddev_pop() on columns of table "genres"
input genres_stddev_pop_order_by {
  id: order_by
}

# aggregate stddev_samp on columns
type genres_stddev_samp_fields {
  id: Float
}

# order by stddev_samp() on columns of table "genres"
input genres_stddev_samp_order_by {
  id: order_by
}

# aggregate sum on columns
type genres_sum_fields {
  id: Int
}

# order by sum() on columns of table "genres"
input genres_sum_order_by {
  id: order_by
}

# update columns of table "genres"
enum genres_update_column {
  # column name
  id

  # column name
  name
}

# aggregate var_pop on columns
type genres_var_pop_fields {
  id: Float
}

# order by var_pop() on columns of table "genres"
input genres_var_pop_order_by {
  id: order_by
}

# aggregate var_samp on columns
type genres_var_samp_fields {
  id: Float
}

# order by var_samp() on columns of table "genres"
input genres_var_samp_order_by {
  id: order_by
}

# aggregate variance on columns
type genres_variance_fields {
  id: Float
}

# order by variance() on columns of table "genres"
input genres_variance_order_by {
  id: order_by
}

# expression to compare columns of type Int. All fields are combined with logical 'AND'.
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

# columns and relationships of "invoice_lines"
type invoice_lines {
  id: Int!

  # An object relationship
  invoice: invoices!
  invoice_id: Int!
  quantity: Int!

  # An object relationship
  track: tracks!
  track_id: Int!
  unit_price: numeric!
}

# aggregated selection of "invoice_lines"
type invoice_lines_aggregate {
  aggregate: invoice_lines_aggregate_fields
  nodes: [invoice_lines!]!
}

# aggregate fields of "invoice_lines"
type invoice_lines_aggregate_fields {
  avg: invoice_lines_avg_fields
  count(columns: [invoice_lines_select_column!], distinct: Boolean): Int
  max: invoice_lines_max_fields
  min: invoice_lines_min_fields
  stddev: invoice_lines_stddev_fields
  stddev_pop: invoice_lines_stddev_pop_fields
  stddev_samp: invoice_lines_stddev_samp_fields
  sum: invoice_lines_sum_fields
  var_pop: invoice_lines_var_pop_fields
  var_samp: invoice_lines_var_samp_fields
  variance: invoice_lines_variance_fields
}

# order by aggregate values of table "invoice_lines"
input invoice_lines_aggregate_order_by {
  avg: invoice_lines_avg_order_by
  count: order_by
  max: invoice_lines_max_order_by
  min: invoice_lines_min_order_by
  stddev: invoice_lines_stddev_order_by
  stddev_pop: invoice_lines_stddev_pop_order_by
  stddev_samp: invoice_lines_stddev_samp_order_by
  sum: invoice_lines_sum_order_by
  var_pop: invoice_lines_var_pop_order_by
  var_samp: invoice_lines_var_samp_order_by
  variance: invoice_lines_variance_order_by
}

# input type for inserting array relation for remote table "invoice_lines"
input invoice_lines_arr_rel_insert_input {
  data: [invoice_lines_insert_input!]!
  on_conflict: invoice_lines_on_conflict
}

# aggregate avg on columns
type invoice_lines_avg_fields {
  id: Float
  invoice_id: Float
  quantity: Float
  track_id: Float
  unit_price: Float
}

# order by avg() on columns of table "invoice_lines"
input invoice_lines_avg_order_by {
  id: order_by
  invoice_id: order_by
  quantity: order_by
  track_id: order_by
  unit_price: order_by
}

# Boolean expression to filter rows from the table "invoice_lines". All fields are combined with a logical 'AND'.
input invoice_lines_bool_exp {
  _and: [invoice_lines_bool_exp]
  _not: invoice_lines_bool_exp
  _or: [invoice_lines_bool_exp]
  id: Int_comparison_exp
  invoice: invoices_bool_exp
  invoice_id: Int_comparison_exp
  quantity: Int_comparison_exp
  track: tracks_bool_exp
  track_id: Int_comparison_exp
  unit_price: numeric_comparison_exp
}

# unique or primary key constraints on table "invoice_lines"
enum invoice_lines_constraint {
  # unique or primary key constraint
  ok_invoice_lines
}

# input type for incrementing integer column in table "invoice_lines"
input invoice_lines_inc_input {
  id: Int
  invoice_id: Int
  quantity: Int
  track_id: Int
  unit_price: numeric
}

# input type for inserting data into table "invoice_lines"
input invoice_lines_insert_input {
  id: Int
  invoice: invoices_obj_rel_insert_input
  invoice_id: Int
  quantity: Int
  track: tracks_obj_rel_insert_input
  track_id: Int
  unit_price: numeric
}

# aggregate max on columns
type invoice_lines_max_fields {
  id: Int
  invoice_id: Int
  quantity: Int
  track_id: Int
  unit_price: numeric
}

# order by max() on columns of table "invoice_lines"
input invoice_lines_max_order_by {
  id: order_by
  invoice_id: order_by
  quantity: order_by
  track_id: order_by
  unit_price: order_by
}

# aggregate min on columns
type invoice_lines_min_fields {
  id: Int
  invoice_id: Int
  quantity: Int
  track_id: Int
  unit_price: numeric
}

# order by min() on columns of table "invoice_lines"
input invoice_lines_min_order_by {
  id: order_by
  invoice_id: order_by
  quantity: order_by
  track_id: order_by
  unit_price: order_by
}

# response of any mutation on the table "invoice_lines"
type invoice_lines_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [invoice_lines!]!
}

# input type for inserting object relation for remote table "invoice_lines"
input invoice_lines_obj_rel_insert_input {
  data: invoice_lines_insert_input!
  on_conflict: invoice_lines_on_conflict
}

# on conflict condition type for table "invoice_lines"
input invoice_lines_on_conflict {
  constraint: invoice_lines_constraint!
  update_columns: [invoice_lines_update_column!]!
  where: invoice_lines_bool_exp
}

# ordering options when selecting data from "invoice_lines"
input invoice_lines_order_by {
  id: order_by
  invoice: invoices_order_by
  invoice_id: order_by
  quantity: order_by
  track: tracks_order_by
  track_id: order_by
  unit_price: order_by
}

# primary key columns input for table: "invoice_lines"
input invoice_lines_pk_columns_input {
  id: Int!
}

# select columns of table "invoice_lines"
enum invoice_lines_select_column {
  # column name
  id

  # column name
  invoice_id

  # column name
  quantity

  # column name
  track_id

  # column name
  unit_price
}

# input type for updating data in table "invoice_lines"
input invoice_lines_set_input {
  id: Int
  invoice_id: Int
  quantity: Int
  track_id: Int
  unit_price: numeric
}

# aggregate stddev on columns
type invoice_lines_stddev_fields {
  id: Float
  invoice_id: Float
  quantity: Float
  track_id: Float
  unit_price: Float
}

# order by stddev() on columns of table "invoice_lines"
input invoice_lines_stddev_order_by {
  id: order_by
  invoice_id: order_by
  quantity: order_by
  track_id: order_by
  unit_price: order_by
}

# aggregate stddev_pop on columns
type invoice_lines_stddev_pop_fields {
  id: Float
  invoice_id: Float
  quantity: Float
  track_id: Float
  unit_price: Float
}

# order by stddev_pop() on columns of table "invoice_lines"
input invoice_lines_stddev_pop_order_by {
  id: order_by
  invoice_id: order_by
  quantity: order_by
  track_id: order_by
  unit_price: order_by
}

# aggregate stddev_samp on columns
type invoice_lines_stddev_samp_fields {
  id: Float
  invoice_id: Float
  quantity: Float
  track_id: Float
  unit_price: Float
}

# order by stddev_samp() on columns of table "invoice_lines"
input invoice_lines_stddev_samp_order_by {
  id: order_by
  invoice_id: order_by
  quantity: order_by
  track_id: order_by
  unit_price: order_by
}

# aggregate sum on columns
type invoice_lines_sum_fields {
  id: Int
  invoice_id: Int
  quantity: Int
  track_id: Int
  unit_price: numeric
}

# order by sum() on columns of table "invoice_lines"
input invoice_lines_sum_order_by {
  id: order_by
  invoice_id: order_by
  quantity: order_by
  track_id: order_by
  unit_price: order_by
}

# update columns of table "invoice_lines"
enum invoice_lines_update_column {
  # column name
  id

  # column name
  invoice_id

  # column name
  quantity

  # column name
  track_id

  # column name
  unit_price
}

# aggregate var_pop on columns
type invoice_lines_var_pop_fields {
  id: Float
  invoice_id: Float
  quantity: Float
  track_id: Float
  unit_price: Float
}

# order by var_pop() on columns of table "invoice_lines"
input invoice_lines_var_pop_order_by {
  id: order_by
  invoice_id: order_by
  quantity: order_by
  track_id: order_by
  unit_price: order_by
}

# aggregate var_samp on columns
type invoice_lines_var_samp_fields {
  id: Float
  invoice_id: Float
  quantity: Float
  track_id: Float
  unit_price: Float
}

# order by var_samp() on columns of table "invoice_lines"
input invoice_lines_var_samp_order_by {
  id: order_by
  invoice_id: order_by
  quantity: order_by
  track_id: order_by
  unit_price: order_by
}

# aggregate variance on columns
type invoice_lines_variance_fields {
  id: Float
  invoice_id: Float
  quantity: Float
  track_id: Float
  unit_price: Float
}

# order by variance() on columns of table "invoice_lines"
input invoice_lines_variance_order_by {
  id: order_by
  invoice_id: order_by
  quantity: order_by
  track_id: order_by
  unit_price: order_by
}

# columns and relationships of "invoices"
type invoices {
  billing_address: String
  billing_city: String
  billing_country: String
  billing_postal_code: String
  billing_state: String

  # An object relationship
  customer: customers!
  customer_id: Int!
  id: Int!
  invoice_date: timestamp!

  # An array relationship
  invoice_lines(
    # distinct select on columns
    distinct_on: [invoice_lines_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [invoice_lines_order_by!]

    # filter the rows returned
    where: invoice_lines_bool_exp
  ): [invoice_lines!]!

  # An aggregated array relationship
  invoice_lines_aggregate(
    # distinct select on columns
    distinct_on: [invoice_lines_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [invoice_lines_order_by!]

    # filter the rows returned
    where: invoice_lines_bool_exp
  ): invoice_lines_aggregate!
  total: numeric!
}

# aggregated selection of "invoices"
type invoices_aggregate {
  aggregate: invoices_aggregate_fields
  nodes: [invoices!]!
}

# aggregate fields of "invoices"
type invoices_aggregate_fields {
  avg: invoices_avg_fields
  count(columns: [invoices_select_column!], distinct: Boolean): Int
  max: invoices_max_fields
  min: invoices_min_fields
  stddev: invoices_stddev_fields
  stddev_pop: invoices_stddev_pop_fields
  stddev_samp: invoices_stddev_samp_fields
  sum: invoices_sum_fields
  var_pop: invoices_var_pop_fields
  var_samp: invoices_var_samp_fields
  variance: invoices_variance_fields
}

# order by aggregate values of table "invoices"
input invoices_aggregate_order_by {
  avg: invoices_avg_order_by
  count: order_by
  max: invoices_max_order_by
  min: invoices_min_order_by
  stddev: invoices_stddev_order_by
  stddev_pop: invoices_stddev_pop_order_by
  stddev_samp: invoices_stddev_samp_order_by
  sum: invoices_sum_order_by
  var_pop: invoices_var_pop_order_by
  var_samp: invoices_var_samp_order_by
  variance: invoices_variance_order_by
}

# input type for inserting array relation for remote table "invoices"
input invoices_arr_rel_insert_input {
  data: [invoices_insert_input!]!
  on_conflict: invoices_on_conflict
}

# aggregate avg on columns
type invoices_avg_fields {
  customer_id: Float
  id: Float
  total: Float
}

# order by avg() on columns of table "invoices"
input invoices_avg_order_by {
  customer_id: order_by
  id: order_by
  total: order_by
}

# Boolean expression to filter rows from the table "invoices". All fields are combined with a logical 'AND'.
input invoices_bool_exp {
  _and: [invoices_bool_exp]
  _not: invoices_bool_exp
  _or: [invoices_bool_exp]
  billing_address: String_comparison_exp
  billing_city: String_comparison_exp
  billing_country: String_comparison_exp
  billing_postal_code: String_comparison_exp
  billing_state: String_comparison_exp
  customer: customers_bool_exp
  customer_id: Int_comparison_exp
  id: Int_comparison_exp
  invoice_date: timestamp_comparison_exp
  invoice_lines: invoice_lines_bool_exp
  total: numeric_comparison_exp
}

# unique or primary key constraints on table "invoices"
enum invoices_constraint {
  # unique or primary key constraint
  pk_invoices
}

# input type for incrementing integer column in table "invoices"
input invoices_inc_input {
  customer_id: Int
  id: Int
  total: numeric
}

# input type for inserting data into table "invoices"
input invoices_insert_input {
  billing_address: String
  billing_city: String
  billing_country: String
  billing_postal_code: String
  billing_state: String
  customer: customers_obj_rel_insert_input
  customer_id: Int
  id: Int
  invoice_date: timestamp
  invoice_lines: invoice_lines_arr_rel_insert_input
  total: numeric
}

# aggregate max on columns
type invoices_max_fields {
  billing_address: String
  billing_city: String
  billing_country: String
  billing_postal_code: String
  billing_state: String
  customer_id: Int
  id: Int
  invoice_date: timestamp
  total: numeric
}

# order by max() on columns of table "invoices"
input invoices_max_order_by {
  billing_address: order_by
  billing_city: order_by
  billing_country: order_by
  billing_postal_code: order_by
  billing_state: order_by
  customer_id: order_by
  id: order_by
  invoice_date: order_by
  total: order_by
}

# aggregate min on columns
type invoices_min_fields {
  billing_address: String
  billing_city: String
  billing_country: String
  billing_postal_code: String
  billing_state: String
  customer_id: Int
  id: Int
  invoice_date: timestamp
  total: numeric
}

# order by min() on columns of table "invoices"
input invoices_min_order_by {
  billing_address: order_by
  billing_city: order_by
  billing_country: order_by
  billing_postal_code: order_by
  billing_state: order_by
  customer_id: order_by
  id: order_by
  invoice_date: order_by
  total: order_by
}

# response of any mutation on the table "invoices"
type invoices_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [invoices!]!
}

# input type for inserting object relation for remote table "invoices"
input invoices_obj_rel_insert_input {
  data: invoices_insert_input!
  on_conflict: invoices_on_conflict
}

# on conflict condition type for table "invoices"
input invoices_on_conflict {
  constraint: invoices_constraint!
  update_columns: [invoices_update_column!]!
  where: invoices_bool_exp
}

# ordering options when selecting data from "invoices"
input invoices_order_by {
  billing_address: order_by
  billing_city: order_by
  billing_country: order_by
  billing_postal_code: order_by
  billing_state: order_by
  customer: customers_order_by
  customer_id: order_by
  id: order_by
  invoice_date: order_by
  invoice_lines_aggregate: invoice_lines_aggregate_order_by
  total: order_by
}

# primary key columns input for table: "invoices"
input invoices_pk_columns_input {
  id: Int!
}

# select columns of table "invoices"
enum invoices_select_column {
  # column name
  billing_address

  # column name
  billing_city

  # column name
  billing_country

  # column name
  billing_postal_code

  # column name
  billing_state

  # column name
  customer_id

  # column name
  id

  # column name
  invoice_date

  # column name
  total
}

# input type for updating data in table "invoices"
input invoices_set_input {
  billing_address: String
  billing_city: String
  billing_country: String
  billing_postal_code: String
  billing_state: String
  customer_id: Int
  id: Int
  invoice_date: timestamp
  total: numeric
}

# aggregate stddev on columns
type invoices_stddev_fields {
  customer_id: Float
  id: Float
  total: Float
}

# order by stddev() on columns of table "invoices"
input invoices_stddev_order_by {
  customer_id: order_by
  id: order_by
  total: order_by
}

# aggregate stddev_pop on columns
type invoices_stddev_pop_fields {
  customer_id: Float
  id: Float
  total: Float
}

# order by stddev_pop() on columns of table "invoices"
input invoices_stddev_pop_order_by {
  customer_id: order_by
  id: order_by
  total: order_by
}

# aggregate stddev_samp on columns
type invoices_stddev_samp_fields {
  customer_id: Float
  id: Float
  total: Float
}

# order by stddev_samp() on columns of table "invoices"
input invoices_stddev_samp_order_by {
  customer_id: order_by
  id: order_by
  total: order_by
}

# aggregate sum on columns
type invoices_sum_fields {
  customer_id: Int
  id: Int
  total: numeric
}

# order by sum() on columns of table "invoices"
input invoices_sum_order_by {
  customer_id: order_by
  id: order_by
  total: order_by
}

# update columns of table "invoices"
enum invoices_update_column {
  # column name
  billing_address

  # column name
  billing_city

  # column name
  billing_country

  # column name
  billing_postal_code

  # column name
  billing_state

  # column name
  customer_id

  # column name
  id

  # column name
  invoice_date

  # column name
  total
}

# aggregate var_pop on columns
type invoices_var_pop_fields {
  customer_id: Float
  id: Float
  total: Float
}

# order by var_pop() on columns of table "invoices"
input invoices_var_pop_order_by {
  customer_id: order_by
  id: order_by
  total: order_by
}

# aggregate var_samp on columns
type invoices_var_samp_fields {
  customer_id: Float
  id: Float
  total: Float
}

# order by var_samp() on columns of table "invoices"
input invoices_var_samp_order_by {
  customer_id: order_by
  id: order_by
  total: order_by
}

# aggregate variance on columns
type invoices_variance_fields {
  customer_id: Float
  id: Float
  total: Float
}

# order by variance() on columns of table "invoices"
input invoices_variance_order_by {
  customer_id: order_by
  id: order_by
  total: order_by
}

scalar json

# expression to compare columns of type json. All fields are combined with logical 'AND'.
input json_comparison_exp {
  _eq: json
  _gt: json
  _gte: json
  _in: [json!]
  _is_null: Boolean
  _lt: json
  _lte: json
  _neq: json
  _nin: [json!]
}

scalar jsonb

# expression to compare columns of type jsonb. All fields are combined with logical 'AND'.
input jsonb_comparison_exp {
  # is the column contained in the given json value
  _contained_in: jsonb

  # does the column contain the given json value at the top level
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb

  # does the string exist as a top-level key in the column
  _has_key: String

  # do all of these strings exist as top-level keys in the column
  _has_keys_all: [String!]

  # do any of these strings exist as top-level keys in the column
  _has_keys_any: [String!]
  _in: [jsonb!]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

# columns and relationships of "media_types"
type media_types {
  id: Int!
  name: String

  # An array relationship
  tracks(
    # distinct select on columns
    distinct_on: [tracks_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [tracks_order_by!]

    # filter the rows returned
    where: tracks_bool_exp
  ): [tracks!]!

  # An aggregated array relationship
  tracks_aggregate(
    # distinct select on columns
    distinct_on: [tracks_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [tracks_order_by!]

    # filter the rows returned
    where: tracks_bool_exp
  ): tracks_aggregate!
}

# aggregated selection of "media_types"
type media_types_aggregate {
  aggregate: media_types_aggregate_fields
  nodes: [media_types!]!
}

# aggregate fields of "media_types"
type media_types_aggregate_fields {
  avg: media_types_avg_fields
  count(columns: [media_types_select_column!], distinct: Boolean): Int
  max: media_types_max_fields
  min: media_types_min_fields
  stddev: media_types_stddev_fields
  stddev_pop: media_types_stddev_pop_fields
  stddev_samp: media_types_stddev_samp_fields
  sum: media_types_sum_fields
  var_pop: media_types_var_pop_fields
  var_samp: media_types_var_samp_fields
  variance: media_types_variance_fields
}

# order by aggregate values of table "media_types"
input media_types_aggregate_order_by {
  avg: media_types_avg_order_by
  count: order_by
  max: media_types_max_order_by
  min: media_types_min_order_by
  stddev: media_types_stddev_order_by
  stddev_pop: media_types_stddev_pop_order_by
  stddev_samp: media_types_stddev_samp_order_by
  sum: media_types_sum_order_by
  var_pop: media_types_var_pop_order_by
  var_samp: media_types_var_samp_order_by
  variance: media_types_variance_order_by
}

# input type for inserting array relation for remote table "media_types"
input media_types_arr_rel_insert_input {
  data: [media_types_insert_input!]!
  on_conflict: media_types_on_conflict
}

# aggregate avg on columns
type media_types_avg_fields {
  id: Float
}

# order by avg() on columns of table "media_types"
input media_types_avg_order_by {
  id: order_by
}

# Boolean expression to filter rows from the table "media_types". All fields are combined with a logical 'AND'.
input media_types_bool_exp {
  _and: [media_types_bool_exp]
  _not: media_types_bool_exp
  _or: [media_types_bool_exp]
  id: Int_comparison_exp
  name: String_comparison_exp
  tracks: tracks_bool_exp
}

# unique or primary key constraints on table "media_types"
enum media_types_constraint {
  # unique or primary key constraint
  pk_media_types
}

# input type for incrementing integer column in table "media_types"
input media_types_inc_input {
  id: Int
}

# input type for inserting data into table "media_types"
input media_types_insert_input {
  id: Int
  name: String
  tracks: tracks_arr_rel_insert_input
}

# aggregate max on columns
type media_types_max_fields {
  id: Int
  name: String
}

# order by max() on columns of table "media_types"
input media_types_max_order_by {
  id: order_by
  name: order_by
}

# aggregate min on columns
type media_types_min_fields {
  id: Int
  name: String
}

# order by min() on columns of table "media_types"
input media_types_min_order_by {
  id: order_by
  name: order_by
}

# response of any mutation on the table "media_types"
type media_types_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [media_types!]!
}

# input type for inserting object relation for remote table "media_types"
input media_types_obj_rel_insert_input {
  data: media_types_insert_input!
  on_conflict: media_types_on_conflict
}

# on conflict condition type for table "media_types"
input media_types_on_conflict {
  constraint: media_types_constraint!
  update_columns: [media_types_update_column!]!
  where: media_types_bool_exp
}

# ordering options when selecting data from "media_types"
input media_types_order_by {
  id: order_by
  name: order_by
  tracks_aggregate: tracks_aggregate_order_by
}

# primary key columns input for table: "media_types"
input media_types_pk_columns_input {
  id: Int!
}

# select columns of table "media_types"
enum media_types_select_column {
  # column name
  id

  # column name
  name
}

# input type for updating data in table "media_types"
input media_types_set_input {
  id: Int
  name: String
}

# aggregate stddev on columns
type media_types_stddev_fields {
  id: Float
}

# order by stddev() on columns of table "media_types"
input media_types_stddev_order_by {
  id: order_by
}

# aggregate stddev_pop on columns
type media_types_stddev_pop_fields {
  id: Float
}

# order by stddev_pop() on columns of table "media_types"
input media_types_stddev_pop_order_by {
  id: order_by
}

# aggregate stddev_samp on columns
type media_types_stddev_samp_fields {
  id: Float
}

# order by stddev_samp() on columns of table "media_types"
input media_types_stddev_samp_order_by {
  id: order_by
}

# aggregate sum on columns
type media_types_sum_fields {
  id: Int
}

# order by sum() on columns of table "media_types"
input media_types_sum_order_by {
  id: order_by
}

# update columns of table "media_types"
enum media_types_update_column {
  # column name
  id

  # column name
  name
}

# aggregate var_pop on columns
type media_types_var_pop_fields {
  id: Float
}

# order by var_pop() on columns of table "media_types"
input media_types_var_pop_order_by {
  id: order_by
}

# aggregate var_samp on columns
type media_types_var_samp_fields {
  id: Float
}

# order by var_samp() on columns of table "media_types"
input media_types_var_samp_order_by {
  id: order_by
}

# aggregate variance on columns
type media_types_variance_fields {
  id: Float
}

# order by variance() on columns of table "media_types"
input media_types_variance_order_by {
  id: order_by
}

# mutation root
type mutation_root {
  # perform the action: "actionName"
  actionName(arg1: SampleInput!): SampleOutput

  # delete data from the table: "actors"
  delete_actors(
    # filter the rows which have to be deleted
    where: actors_bool_exp!
  ): actors_mutation_response

  # delete single row from the table: "actors"
  delete_actors_by_pk(id: Int!): actors

  # delete data from the table: "albums"
  delete_albums(
    # filter the rows which have to be deleted
    where: albums_bool_exp!
  ): albums_mutation_response

  # delete single row from the table: "albums"
  delete_albums_by_pk(id: Int!): albums

  # delete data from the table: "artists"
  delete_artists(
    # filter the rows which have to be deleted
    where: artists_bool_exp!
  ): artists_mutation_response

  # delete single row from the table: "artists"
  delete_artists_by_pk(id: Int!): artists

  # delete data from the table: "categories"
  delete_categories(
    # filter the rows which have to be deleted
    where: categories_bool_exp!
  ): categories_mutation_response

  # delete single row from the table: "categories"
  delete_categories_by_pk(id: Int!): categories

  # delete data from the table: "customers"
  delete_customers(
    # filter the rows which have to be deleted
    where: customers_bool_exp!
  ): customers_mutation_response

  # delete single row from the table: "customers"
  delete_customers_by_pk(id: Int!): customers

  # delete data from the table: "employees"
  delete_employees(
    # filter the rows which have to be deleted
    where: employees_bool_exp!
  ): employees_mutation_response

  # delete single row from the table: "employees"
  delete_employees_by_pk(id: Int!): employees

  # delete data from the table: "events"
  delete_events(
    # filter the rows which have to be deleted
    where: events_bool_exp!
  ): events_mutation_response

  # delete data from the table: "film_actor"
  delete_film_actor(
    # filter the rows which have to be deleted
    where: film_actor_bool_exp!
  ): film_actor_mutation_response

  # delete single row from the table: "film_actor"
  delete_film_actor_by_pk(actor_id: smallint!, film_id: smallint!): film_actor

  # delete data from the table: "film_category"
  delete_film_category(
    # filter the rows which have to be deleted
    where: film_category_bool_exp!
  ): film_category_mutation_response

  # delete data from the table: "films"
  delete_films(
    # filter the rows which have to be deleted
    where: films_bool_exp!
  ): films_mutation_response

  # delete single row from the table: "films"
  delete_films_by_pk(id: Int!): films

  # delete data from the table: "genres"
  delete_genres(
    # filter the rows which have to be deleted
    where: genres_bool_exp!
  ): genres_mutation_response

  # delete single row from the table: "genres"
  delete_genres_by_pk(id: Int!): genres

  # delete data from the table: "invoice_lines"
  delete_invoice_lines(
    # filter the rows which have to be deleted
    where: invoice_lines_bool_exp!
  ): invoice_lines_mutation_response

  # delete single row from the table: "invoice_lines"
  delete_invoice_lines_by_pk(id: Int!): invoice_lines

  # delete data from the table: "invoices"
  delete_invoices(
    # filter the rows which have to be deleted
    where: invoices_bool_exp!
  ): invoices_mutation_response

  # delete single row from the table: "invoices"
  delete_invoices_by_pk(id: Int!): invoices

  # delete data from the table: "media_types"
  delete_media_types(
    # filter the rows which have to be deleted
    where: media_types_bool_exp!
  ): media_types_mutation_response

  # delete single row from the table: "media_types"
  delete_media_types_by_pk(id: Int!): media_types

  # delete data from the table: "my_table"
  delete_my_table_custom(
    # filter the rows which have to be deleted
    where: my_table_bool_exp!
  ): my_table_mutation_response

  # delete data from the table: "playlist_track"
  delete_playlist_track(
    # filter the rows which have to be deleted
    where: playlist_track_bool_exp!
  ): playlist_track_mutation_response

  # delete single row from the table: "playlist_track"
  delete_playlist_track_by_pk(playlist_id: Int!, track_id: Int!): playlist_track

  # delete data from the table: "playlists"
  delete_playlists(
    # filter the rows which have to be deleted
    where: playlists_bool_exp!
  ): playlists_mutation_response

  # delete single row from the table: "playlists"
  delete_playlists_by_pk(id: Int!): playlists

  # delete data from the table: "tracks"
  delete_tracks(
    # filter the rows which have to be deleted
    where: tracks_bool_exp!
  ): tracks_mutation_response

  # delete single row from the table: "tracks"
  delete_tracks_by_pk(id: Int!): tracks

  # insert data into the table: "actors"
  insert_actors(
    # the rows to be inserted
    objects: [actors_insert_input!]!

    # on conflict condition
    on_conflict: actors_on_conflict
  ): actors_mutation_response

  # insert a single row into the table: "actors"
  insert_actors_one(
    # the row to be inserted
    object: actors_insert_input!

    # on conflict condition
    on_conflict: actors_on_conflict
  ): actors

  # insert data into the table: "albums"
  insert_albums(
    # the rows to be inserted
    objects: [albums_insert_input!]!

    # on conflict condition
    on_conflict: albums_on_conflict
  ): albums_mutation_response

  # insert a single row into the table: "albums"
  insert_albums_one(
    # the row to be inserted
    object: albums_insert_input!

    # on conflict condition
    on_conflict: albums_on_conflict
  ): albums

  # insert data into the table: "artists"
  insert_artists(
    # the rows to be inserted
    objects: [artists_insert_input!]!

    # on conflict condition
    on_conflict: artists_on_conflict
  ): artists_mutation_response

  # insert a single row into the table: "artists"
  insert_artists_one(
    # the row to be inserted
    object: artists_insert_input!

    # on conflict condition
    on_conflict: artists_on_conflict
  ): artists

  # insert data into the table: "categories"
  insert_categories(
    # the rows to be inserted
    objects: [categories_insert_input!]!

    # on conflict condition
    on_conflict: categories_on_conflict
  ): categories_mutation_response

  # insert a single row into the table: "categories"
  insert_categories_one(
    # the row to be inserted
    object: categories_insert_input!

    # on conflict condition
    on_conflict: categories_on_conflict
  ): categories

  # insert data into the table: "customers"
  insert_customers(
    # the rows to be inserted
    objects: [customers_insert_input!]!

    # on conflict condition
    on_conflict: customers_on_conflict
  ): customers_mutation_response

  # insert a single row into the table: "customers"
  insert_customers_one(
    # the row to be inserted
    object: customers_insert_input!

    # on conflict condition
    on_conflict: customers_on_conflict
  ): customers

  # insert data into the table: "employees"
  insert_employees(
    # the rows to be inserted
    objects: [employees_insert_input!]!

    # on conflict condition
    on_conflict: employees_on_conflict
  ): employees_mutation_response

  # insert a single row into the table: "employees"
  insert_employees_one(
    # the row to be inserted
    object: employees_insert_input!

    # on conflict condition
    on_conflict: employees_on_conflict
  ): employees

  # insert data into the table: "events"
  insert_events(
    # the rows to be inserted
    objects: [events_insert_input!]!

    # on conflict condition
    on_conflict: events_on_conflict
  ): events_mutation_response

  # insert a single row into the table: "events"
  insert_events_one(
    # the row to be inserted
    object: events_insert_input!

    # on conflict condition
    on_conflict: events_on_conflict
  ): events

  # insert data into the table: "film_actor"
  insert_film_actor(
    # the rows to be inserted
    objects: [film_actor_insert_input!]!

    # on conflict condition
    on_conflict: film_actor_on_conflict
  ): film_actor_mutation_response

  # insert a single row into the table: "film_actor"
  insert_film_actor_one(
    # the row to be inserted
    object: film_actor_insert_input!

    # on conflict condition
    on_conflict: film_actor_on_conflict
  ): film_actor

  # insert data into the table: "film_category"
  insert_film_category(
    # the rows to be inserted
    objects: [film_category_insert_input!]!
  ): film_category_mutation_response

  # insert a single row into the table: "film_category"
  insert_film_category_one(
    # the row to be inserted
    object: film_category_insert_input!
  ): film_category

  # insert data into the table: "films"
  insert_films(
    # the rows to be inserted
    objects: [films_insert_input!]!

    # on conflict condition
    on_conflict: films_on_conflict
  ): films_mutation_response

  # insert a single row into the table: "films"
  insert_films_one(
    # the row to be inserted
    object: films_insert_input!

    # on conflict condition
    on_conflict: films_on_conflict
  ): films

  # insert data into the table: "genres"
  insert_genres(
    # the rows to be inserted
    objects: [genres_insert_input!]!

    # on conflict condition
    on_conflict: genres_on_conflict
  ): genres_mutation_response

  # insert a single row into the table: "genres"
  insert_genres_one(
    # the row to be inserted
    object: genres_insert_input!

    # on conflict condition
    on_conflict: genres_on_conflict
  ): genres

  # insert data into the table: "invoice_lines"
  insert_invoice_lines(
    # the rows to be inserted
    objects: [invoice_lines_insert_input!]!

    # on conflict condition
    on_conflict: invoice_lines_on_conflict
  ): invoice_lines_mutation_response

  # insert a single row into the table: "invoice_lines"
  insert_invoice_lines_one(
    # the row to be inserted
    object: invoice_lines_insert_input!

    # on conflict condition
    on_conflict: invoice_lines_on_conflict
  ): invoice_lines

  # insert data into the table: "invoices"
  insert_invoices(
    # the rows to be inserted
    objects: [invoices_insert_input!]!

    # on conflict condition
    on_conflict: invoices_on_conflict
  ): invoices_mutation_response

  # insert a single row into the table: "invoices"
  insert_invoices_one(
    # the row to be inserted
    object: invoices_insert_input!

    # on conflict condition
    on_conflict: invoices_on_conflict
  ): invoices

  # insert data into the table: "media_types"
  insert_media_types(
    # the rows to be inserted
    objects: [media_types_insert_input!]!

    # on conflict condition
    on_conflict: media_types_on_conflict
  ): media_types_mutation_response

  # insert a single row into the table: "media_types"
  insert_media_types_one(
    # the row to be inserted
    object: media_types_insert_input!

    # on conflict condition
    on_conflict: media_types_on_conflict
  ): media_types

  # insert data into the table: "my_table"
  insert_my_table_custom(
    # the rows to be inserted
    objects: [my_table_insert_input!]!
  ): my_table_mutation_response

  # insert a single row into the table: "my_table"
  insert_one_my_table_custom(
    # the row to be inserted
    object: my_table_insert_input!
  ): my_table

  # insert data into the table: "playlist_track"
  insert_playlist_track(
    # the rows to be inserted
    objects: [playlist_track_insert_input!]!

    # on conflict condition
    on_conflict: playlist_track_on_conflict
  ): playlist_track_mutation_response

  # insert a single row into the table: "playlist_track"
  insert_playlist_track_one(
    # the row to be inserted
    object: playlist_track_insert_input!

    # on conflict condition
    on_conflict: playlist_track_on_conflict
  ): playlist_track

  # insert data into the table: "playlists"
  insert_playlists(
    # the rows to be inserted
    objects: [playlists_insert_input!]!

    # on conflict condition
    on_conflict: playlists_on_conflict
  ): playlists_mutation_response

  # insert a single row into the table: "playlists"
  insert_playlists_one(
    # the row to be inserted
    object: playlists_insert_input!

    # on conflict condition
    on_conflict: playlists_on_conflict
  ): playlists

  # insert data into the table: "tracks"
  insert_tracks(
    # the rows to be inserted
    objects: [tracks_insert_input!]!

    # on conflict condition
    on_conflict: tracks_on_conflict
  ): tracks_mutation_response

  # insert a single row into the table: "tracks"
  insert_tracks_one(
    # the row to be inserted
    object: tracks_insert_input!

    # on conflict condition
    on_conflict: tracks_on_conflict
  ): tracks

  # update data of the table: "actors"
  update_actors(
    # increments the integer columns with given value of the filtered values
    _inc: actors_inc_input

    # sets the columns of the filtered rows to the given values
    _set: actors_set_input

    # filter the rows which have to be updated
    where: actors_bool_exp!
  ): actors_mutation_response

  # update single row of the table: "actors"
  update_actors_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: actors_inc_input

    # sets the columns of the filtered rows to the given values
    _set: actors_set_input
    pk_columns: actors_pk_columns_input!
  ): actors

  # update data of the table: "albums"
  update_albums(
    # increments the integer columns with given value of the filtered values
    _inc: albums_inc_input

    # sets the columns of the filtered rows to the given values
    _set: albums_set_input

    # filter the rows which have to be updated
    where: albums_bool_exp!
  ): albums_mutation_response

  # update single row of the table: "albums"
  update_albums_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: albums_inc_input

    # sets the columns of the filtered rows to the given values
    _set: albums_set_input
    pk_columns: albums_pk_columns_input!
  ): albums

  # update data of the table: "artists"
  update_artists(
    # increments the integer columns with given value of the filtered values
    _inc: artists_inc_input

    # sets the columns of the filtered rows to the given values
    _set: artists_set_input

    # filter the rows which have to be updated
    where: artists_bool_exp!
  ): artists_mutation_response

  # update single row of the table: "artists"
  update_artists_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: artists_inc_input

    # sets the columns of the filtered rows to the given values
    _set: artists_set_input
    pk_columns: artists_pk_columns_input!
  ): artists

  # update data of the table: "categories"
  update_categories(
    # increments the integer columns with given value of the filtered values
    _inc: categories_inc_input

    # sets the columns of the filtered rows to the given values
    _set: categories_set_input

    # filter the rows which have to be updated
    where: categories_bool_exp!
  ): categories_mutation_response

  # update single row of the table: "categories"
  update_categories_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: categories_inc_input

    # sets the columns of the filtered rows to the given values
    _set: categories_set_input
    pk_columns: categories_pk_columns_input!
  ): categories

  # update data of the table: "customers"
  update_customers(
    # increments the integer columns with given value of the filtered values
    _inc: customers_inc_input

    # sets the columns of the filtered rows to the given values
    _set: customers_set_input

    # filter the rows which have to be updated
    where: customers_bool_exp!
  ): customers_mutation_response

  # update single row of the table: "customers"
  update_customers_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: customers_inc_input

    # sets the columns of the filtered rows to the given values
    _set: customers_set_input
    pk_columns: customers_pk_columns_input!
  ): customers

  # update data of the table: "employees"
  update_employees(
    # increments the integer columns with given value of the filtered values
    _inc: employees_inc_input

    # sets the columns of the filtered rows to the given values
    _set: employees_set_input

    # filter the rows which have to be updated
    where: employees_bool_exp!
  ): employees_mutation_response

  # update single row of the table: "employees"
  update_employees_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: employees_inc_input

    # sets the columns of the filtered rows to the given values
    _set: employees_set_input
    pk_columns: employees_pk_columns_input!
  ): employees

  # update data of the table: "events"
  update_events(
    # append existing jsonb value of filtered columns with new jsonb value
    _append: events_append_input

    # delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    _delete_at_path: events_delete_at_path_input

    # delete the array element with specified index (negative integers count from
    # the end). throws an error if top level container is not an array
    _delete_elem: events_delete_elem_input

    # delete key/value pair or string element. key/value pairs are matched based on their key value
    _delete_key: events_delete_key_input

    # increments the integer columns with given value of the filtered values
    _inc: events_inc_input

    # prepend existing jsonb value of filtered columns with new jsonb value
    _prepend: events_prepend_input

    # sets the columns of the filtered rows to the given values
    _set: events_set_input

    # filter the rows which have to be updated
    where: events_bool_exp!
  ): events_mutation_response

  # update data of the table: "film_actor"
  update_film_actor(
    # increments the integer columns with given value of the filtered values
    _inc: film_actor_inc_input

    # sets the columns of the filtered rows to the given values
    _set: film_actor_set_input

    # filter the rows which have to be updated
    where: film_actor_bool_exp!
  ): film_actor_mutation_response

  # update single row of the table: "film_actor"
  update_film_actor_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: film_actor_inc_input

    # sets the columns of the filtered rows to the given values
    _set: film_actor_set_input
    pk_columns: film_actor_pk_columns_input!
  ): film_actor

  # update data of the table: "film_category"
  update_film_category(
    # increments the integer columns with given value of the filtered values
    _inc: film_category_inc_input

    # sets the columns of the filtered rows to the given values
    _set: film_category_set_input

    # filter the rows which have to be updated
    where: film_category_bool_exp!
  ): film_category_mutation_response

  # update data of the table: "films"
  update_films(
    # increments the integer columns with given value of the filtered values
    _inc: films_inc_input

    # sets the columns of the filtered rows to the given values
    _set: films_set_input

    # filter the rows which have to be updated
    where: films_bool_exp!
  ): films_mutation_response

  # update single row of the table: "films"
  update_films_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: films_inc_input

    # sets the columns of the filtered rows to the given values
    _set: films_set_input
    pk_columns: films_pk_columns_input!
  ): films

  # update data of the table: "genres"
  update_genres(
    # increments the integer columns with given value of the filtered values
    _inc: genres_inc_input

    # sets the columns of the filtered rows to the given values
    _set: genres_set_input

    # filter the rows which have to be updated
    where: genres_bool_exp!
  ): genres_mutation_response

  # update single row of the table: "genres"
  update_genres_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: genres_inc_input

    # sets the columns of the filtered rows to the given values
    _set: genres_set_input
    pk_columns: genres_pk_columns_input!
  ): genres

  # update data of the table: "invoice_lines"
  update_invoice_lines(
    # increments the integer columns with given value of the filtered values
    _inc: invoice_lines_inc_input

    # sets the columns of the filtered rows to the given values
    _set: invoice_lines_set_input

    # filter the rows which have to be updated
    where: invoice_lines_bool_exp!
  ): invoice_lines_mutation_response

  # update single row of the table: "invoice_lines"
  update_invoice_lines_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: invoice_lines_inc_input

    # sets the columns of the filtered rows to the given values
    _set: invoice_lines_set_input
    pk_columns: invoice_lines_pk_columns_input!
  ): invoice_lines

  # update data of the table: "invoices"
  update_invoices(
    # increments the integer columns with given value of the filtered values
    _inc: invoices_inc_input

    # sets the columns of the filtered rows to the given values
    _set: invoices_set_input

    # filter the rows which have to be updated
    where: invoices_bool_exp!
  ): invoices_mutation_response

  # update single row of the table: "invoices"
  update_invoices_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: invoices_inc_input

    # sets the columns of the filtered rows to the given values
    _set: invoices_set_input
    pk_columns: invoices_pk_columns_input!
  ): invoices

  # update data of the table: "media_types"
  update_media_types(
    # increments the integer columns with given value of the filtered values
    _inc: media_types_inc_input

    # sets the columns of the filtered rows to the given values
    _set: media_types_set_input

    # filter the rows which have to be updated
    where: media_types_bool_exp!
  ): media_types_mutation_response

  # update single row of the table: "media_types"
  update_media_types_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: media_types_inc_input

    # sets the columns of the filtered rows to the given values
    _set: media_types_set_input
    pk_columns: media_types_pk_columns_input!
  ): media_types

  # update data of the table: "my_table"
  update_my_table_custom(
    # append existing jsonb value of filtered columns with new jsonb value
    _append: my_table_append_input

    # delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    _delete_at_path: my_table_delete_at_path_input

    # delete the array element with specified index (negative integers count from
    # the end). throws an error if top level container is not an array
    _delete_elem: my_table_delete_elem_input

    # delete key/value pair or string element. key/value pairs are matched based on their key value
    _delete_key: my_table_delete_key_input

    # prepend existing jsonb value of filtered columns with new jsonb value
    _prepend: my_table_prepend_input

    # sets the columns of the filtered rows to the given values
    _set: my_table_set_input

    # filter the rows which have to be updated
    where: my_table_bool_exp!
  ): my_table_mutation_response

  # update data of the table: "playlist_track"
  update_playlist_track(
    # increments the integer columns with given value of the filtered values
    _inc: playlist_track_inc_input

    # sets the columns of the filtered rows to the given values
    _set: playlist_track_set_input

    # filter the rows which have to be updated
    where: playlist_track_bool_exp!
  ): playlist_track_mutation_response

  # update single row of the table: "playlist_track"
  update_playlist_track_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: playlist_track_inc_input

    # sets the columns of the filtered rows to the given values
    _set: playlist_track_set_input
    pk_columns: playlist_track_pk_columns_input!
  ): playlist_track

  # update data of the table: "playlists"
  update_playlists(
    # increments the integer columns with given value of the filtered values
    _inc: playlists_inc_input

    # sets the columns of the filtered rows to the given values
    _set: playlists_set_input

    # filter the rows which have to be updated
    where: playlists_bool_exp!
  ): playlists_mutation_response

  # update single row of the table: "playlists"
  update_playlists_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: playlists_inc_input

    # sets the columns of the filtered rows to the given values
    _set: playlists_set_input
    pk_columns: playlists_pk_columns_input!
  ): playlists

  # update data of the table: "tracks"
  update_tracks(
    # increments the integer columns with given value of the filtered values
    _inc: tracks_inc_input

    # sets the columns of the filtered rows to the given values
    _set: tracks_set_input

    # filter the rows which have to be updated
    where: tracks_bool_exp!
  ): tracks_mutation_response

  # update single row of the table: "tracks"
  update_tracks_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: tracks_inc_input

    # sets the columns of the filtered rows to the given values
    _set: tracks_set_input
    pk_columns: tracks_pk_columns_input!
  ): tracks
}

# columns and relationships of "my_table"
type my_table {
  a_json_column(
    # JSON select path
    path: String
  ): jsonb
  my_array: _numeric
  squares: _int4
}

# aggregated selection of "my_table"
type my_table_aggregate {
  aggregate: my_table_aggregate_fields
  nodes: [my_table!]!
}

# aggregate fields of "my_table"
type my_table_aggregate_fields {
  count(columns: [my_table_select_column!], distinct: Boolean): Int
}

# order by aggregate values of table "my_table"
input my_table_aggregate_order_by {
  count: order_by
}

# append existing jsonb value of filtered columns with new jsonb value
input my_table_append_input {
  a_json_column: jsonb
}

# input type for inserting array relation for remote table "my_table"
input my_table_arr_rel_insert_input {
  data: [my_table_insert_input!]!
}

# Boolean expression to filter rows from the table "my_table". All fields are combined with a logical 'AND'.
input my_table_bool_exp {
  _and: [my_table_bool_exp]
  _not: my_table_bool_exp
  _or: [my_table_bool_exp]
  a_json_column: jsonb_comparison_exp
  my_array: _numeric_comparison_exp
  squares: _int4_comparison_exp
}

# delete the field or element with specified path (for JSON arrays, negative integers count from the end)
input my_table_delete_at_path_input {
  a_json_column: [String]
}

# delete the array element with specified index (negative integers count from the
# end). throws an error if top level container is not an array
input my_table_delete_elem_input {
  a_json_column: Int
}

# delete key/value pair or string element. key/value pairs are matched based on their key value
input my_table_delete_key_input {
  a_json_column: String
}

# input type for inserting data into table "my_table"
input my_table_insert_input {
  a_json_column: jsonb
  my_array: _numeric
  squares: _int4
}

# response of any mutation on the table "my_table"
type my_table_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [my_table!]!
}

# input type for inserting object relation for remote table "my_table"
input my_table_obj_rel_insert_input {
  data: my_table_insert_input!
}

# ordering options when selecting data from "my_table"
input my_table_order_by {
  a_json_column: order_by
  my_array: order_by
  squares: order_by
}

# prepend existing jsonb value of filtered columns with new jsonb value
input my_table_prepend_input {
  a_json_column: jsonb
}

# select columns of table "my_table"
enum my_table_select_column {
  # column name
  a_json_column

  # column name
  my_array

  # column name
  squares
}

# input type for updating data in table "my_table"
input my_table_set_input {
  a_json_column: jsonb
  my_array: _numeric
  squares: _int4
}

scalar numeric

# expression to compare columns of type numeric. All fields are combined with logical 'AND'.
input numeric_comparison_exp {
  _eq: numeric
  _gt: numeric
  _gte: numeric
  _in: [numeric!]
  _is_null: Boolean
  _lt: numeric
  _lte: numeric
  _neq: numeric
  _nin: [numeric!]
}

# column ordering options
enum order_by {
  # in the ascending order, nulls last
  asc

  # in the ascending order, nulls first
  asc_nulls_first

  # in the ascending order, nulls last
  asc_nulls_last

  # in the descending order, nulls first
  desc

  # in the descending order, nulls first
  desc_nulls_first

  # in the descending order, nulls last
  desc_nulls_last
}

# columns and relationships of "playlist_track"
type playlist_track {
  # An object relationship
  playlist: playlists!
  playlist_id: Int!

  # An object relationship
  track: tracks!
  track_id: Int!
}

# aggregated selection of "playlist_track"
type playlist_track_aggregate {
  aggregate: playlist_track_aggregate_fields
  nodes: [playlist_track!]!
}

# aggregate fields of "playlist_track"
type playlist_track_aggregate_fields {
  avg: playlist_track_avg_fields
  count(columns: [playlist_track_select_column!], distinct: Boolean): Int
  max: playlist_track_max_fields
  min: playlist_track_min_fields
  stddev: playlist_track_stddev_fields
  stddev_pop: playlist_track_stddev_pop_fields
  stddev_samp: playlist_track_stddev_samp_fields
  sum: playlist_track_sum_fields
  var_pop: playlist_track_var_pop_fields
  var_samp: playlist_track_var_samp_fields
  variance: playlist_track_variance_fields
}

# order by aggregate values of table "playlist_track"
input playlist_track_aggregate_order_by {
  avg: playlist_track_avg_order_by
  count: order_by
  max: playlist_track_max_order_by
  min: playlist_track_min_order_by
  stddev: playlist_track_stddev_order_by
  stddev_pop: playlist_track_stddev_pop_order_by
  stddev_samp: playlist_track_stddev_samp_order_by
  sum: playlist_track_sum_order_by
  var_pop: playlist_track_var_pop_order_by
  var_samp: playlist_track_var_samp_order_by
  variance: playlist_track_variance_order_by
}

# input type for inserting array relation for remote table "playlist_track"
input playlist_track_arr_rel_insert_input {
  data: [playlist_track_insert_input!]!
  on_conflict: playlist_track_on_conflict
}

# aggregate avg on columns
type playlist_track_avg_fields {
  playlist_id: Float
  track_id: Float
}

# order by avg() on columns of table "playlist_track"
input playlist_track_avg_order_by {
  playlist_id: order_by
  track_id: order_by
}

# Boolean expression to filter rows from the table "playlist_track". All fields are combined with a logical 'AND'.
input playlist_track_bool_exp {
  _and: [playlist_track_bool_exp]
  _not: playlist_track_bool_exp
  _or: [playlist_track_bool_exp]
  playlist: playlists_bool_exp
  playlist_id: Int_comparison_exp
  track: tracks_bool_exp
  track_id: Int_comparison_exp
}

# unique or primary key constraints on table "playlist_track"
enum playlist_track_constraint {
  # unique or primary key constraint
  pk_playlist_track
}

# input type for incrementing integer column in table "playlist_track"
input playlist_track_inc_input {
  playlist_id: Int
  track_id: Int
}

# input type for inserting data into table "playlist_track"
input playlist_track_insert_input {
  playlist: playlists_obj_rel_insert_input
  playlist_id: Int
  track: tracks_obj_rel_insert_input
  track_id: Int
}

# aggregate max on columns
type playlist_track_max_fields {
  playlist_id: Int
  track_id: Int
}

# order by max() on columns of table "playlist_track"
input playlist_track_max_order_by {
  playlist_id: order_by
  track_id: order_by
}

# aggregate min on columns
type playlist_track_min_fields {
  playlist_id: Int
  track_id: Int
}

# order by min() on columns of table "playlist_track"
input playlist_track_min_order_by {
  playlist_id: order_by
  track_id: order_by
}

# response of any mutation on the table "playlist_track"
type playlist_track_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [playlist_track!]!
}

# input type for inserting object relation for remote table "playlist_track"
input playlist_track_obj_rel_insert_input {
  data: playlist_track_insert_input!
  on_conflict: playlist_track_on_conflict
}

# on conflict condition type for table "playlist_track"
input playlist_track_on_conflict {
  constraint: playlist_track_constraint!
  update_columns: [playlist_track_update_column!]!
  where: playlist_track_bool_exp
}

# ordering options when selecting data from "playlist_track"
input playlist_track_order_by {
  playlist: playlists_order_by
  playlist_id: order_by
  track: tracks_order_by
  track_id: order_by
}

# primary key columns input for table: "playlist_track"
input playlist_track_pk_columns_input {
  playlist_id: Int!
  track_id: Int!
}

# select columns of table "playlist_track"
enum playlist_track_select_column {
  # column name
  playlist_id

  # column name
  track_id
}

# input type for updating data in table "playlist_track"
input playlist_track_set_input {
  playlist_id: Int
  track_id: Int
}

# aggregate stddev on columns
type playlist_track_stddev_fields {
  playlist_id: Float
  track_id: Float
}

# order by stddev() on columns of table "playlist_track"
input playlist_track_stddev_order_by {
  playlist_id: order_by
  track_id: order_by
}

# aggregate stddev_pop on columns
type playlist_track_stddev_pop_fields {
  playlist_id: Float
  track_id: Float
}

# order by stddev_pop() on columns of table "playlist_track"
input playlist_track_stddev_pop_order_by {
  playlist_id: order_by
  track_id: order_by
}

# aggregate stddev_samp on columns
type playlist_track_stddev_samp_fields {
  playlist_id: Float
  track_id: Float
}

# order by stddev_samp() on columns of table "playlist_track"
input playlist_track_stddev_samp_order_by {
  playlist_id: order_by
  track_id: order_by
}

# aggregate sum on columns
type playlist_track_sum_fields {
  playlist_id: Int
  track_id: Int
}

# order by sum() on columns of table "playlist_track"
input playlist_track_sum_order_by {
  playlist_id: order_by
  track_id: order_by
}

# update columns of table "playlist_track"
enum playlist_track_update_column {
  # column name
  playlist_id

  # column name
  track_id
}

# aggregate var_pop on columns
type playlist_track_var_pop_fields {
  playlist_id: Float
  track_id: Float
}

# order by var_pop() on columns of table "playlist_track"
input playlist_track_var_pop_order_by {
  playlist_id: order_by
  track_id: order_by
}

# aggregate var_samp on columns
type playlist_track_var_samp_fields {
  playlist_id: Float
  track_id: Float
}

# order by var_samp() on columns of table "playlist_track"
input playlist_track_var_samp_order_by {
  playlist_id: order_by
  track_id: order_by
}

# aggregate variance on columns
type playlist_track_variance_fields {
  playlist_id: Float
  track_id: Float
}

# order by variance() on columns of table "playlist_track"
input playlist_track_variance_order_by {
  playlist_id: order_by
  track_id: order_by
}

# columns and relationships of "playlists"
type playlists {
  id: Int!
  name: String

  # An array relationship
  playlist_tracks(
    # distinct select on columns
    distinct_on: [playlist_track_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [playlist_track_order_by!]

    # filter the rows returned
    where: playlist_track_bool_exp
  ): [playlist_track!]!

  # An aggregated array relationship
  playlist_tracks_aggregate(
    # distinct select on columns
    distinct_on: [playlist_track_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [playlist_track_order_by!]

    # filter the rows returned
    where: playlist_track_bool_exp
  ): playlist_track_aggregate!
}

# aggregated selection of "playlists"
type playlists_aggregate {
  aggregate: playlists_aggregate_fields
  nodes: [playlists!]!
}

# aggregate fields of "playlists"
type playlists_aggregate_fields {
  avg: playlists_avg_fields
  count(columns: [playlists_select_column!], distinct: Boolean): Int
  max: playlists_max_fields
  min: playlists_min_fields
  stddev: playlists_stddev_fields
  stddev_pop: playlists_stddev_pop_fields
  stddev_samp: playlists_stddev_samp_fields
  sum: playlists_sum_fields
  var_pop: playlists_var_pop_fields
  var_samp: playlists_var_samp_fields
  variance: playlists_variance_fields
}

# order by aggregate values of table "playlists"
input playlists_aggregate_order_by {
  avg: playlists_avg_order_by
  count: order_by
  max: playlists_max_order_by
  min: playlists_min_order_by
  stddev: playlists_stddev_order_by
  stddev_pop: playlists_stddev_pop_order_by
  stddev_samp: playlists_stddev_samp_order_by
  sum: playlists_sum_order_by
  var_pop: playlists_var_pop_order_by
  var_samp: playlists_var_samp_order_by
  variance: playlists_variance_order_by
}

# input type for inserting array relation for remote table "playlists"
input playlists_arr_rel_insert_input {
  data: [playlists_insert_input!]!
  on_conflict: playlists_on_conflict
}

# aggregate avg on columns
type playlists_avg_fields {
  id: Float
}

# order by avg() on columns of table "playlists"
input playlists_avg_order_by {
  id: order_by
}

# Boolean expression to filter rows from the table "playlists". All fields are combined with a logical 'AND'.
input playlists_bool_exp {
  _and: [playlists_bool_exp]
  _not: playlists_bool_exp
  _or: [playlists_bool_exp]
  id: Int_comparison_exp
  name: String_comparison_exp
  playlist_tracks: playlist_track_bool_exp
}

# unique or primary key constraints on table "playlists"
enum playlists_constraint {
  # unique or primary key constraint
  pk_playlists
}

# input type for incrementing integer column in table "playlists"
input playlists_inc_input {
  id: Int
}

# input type for inserting data into table "playlists"
input playlists_insert_input {
  id: Int
  name: String
  playlist_tracks: playlist_track_arr_rel_insert_input
}

# aggregate max on columns
type playlists_max_fields {
  id: Int
  name: String
}

# order by max() on columns of table "playlists"
input playlists_max_order_by {
  id: order_by
  name: order_by
}

# aggregate min on columns
type playlists_min_fields {
  id: Int
  name: String
}

# order by min() on columns of table "playlists"
input playlists_min_order_by {
  id: order_by
  name: order_by
}

# response of any mutation on the table "playlists"
type playlists_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [playlists!]!
}

# input type for inserting object relation for remote table "playlists"
input playlists_obj_rel_insert_input {
  data: playlists_insert_input!
  on_conflict: playlists_on_conflict
}

# on conflict condition type for table "playlists"
input playlists_on_conflict {
  constraint: playlists_constraint!
  update_columns: [playlists_update_column!]!
  where: playlists_bool_exp
}

# ordering options when selecting data from "playlists"
input playlists_order_by {
  id: order_by
  name: order_by
  playlist_tracks_aggregate: playlist_track_aggregate_order_by
}

# primary key columns input for table: "playlists"
input playlists_pk_columns_input {
  id: Int!
}

# select columns of table "playlists"
enum playlists_select_column {
  # column name
  id

  # column name
  name
}

# input type for updating data in table "playlists"
input playlists_set_input {
  id: Int
  name: String
}

# aggregate stddev on columns
type playlists_stddev_fields {
  id: Float
}

# order by stddev() on columns of table "playlists"
input playlists_stddev_order_by {
  id: order_by
}

# aggregate stddev_pop on columns
type playlists_stddev_pop_fields {
  id: Float
}

# order by stddev_pop() on columns of table "playlists"
input playlists_stddev_pop_order_by {
  id: order_by
}

# aggregate stddev_samp on columns
type playlists_stddev_samp_fields {
  id: Float
}

# order by stddev_samp() on columns of table "playlists"
input playlists_stddev_samp_order_by {
  id: order_by
}

# aggregate sum on columns
type playlists_sum_fields {
  id: Int
}

# order by sum() on columns of table "playlists"
input playlists_sum_order_by {
  id: order_by
}

# update columns of table "playlists"
enum playlists_update_column {
  # column name
  id

  # column name
  name
}

# aggregate var_pop on columns
type playlists_var_pop_fields {
  id: Float
}

# order by var_pop() on columns of table "playlists"
input playlists_var_pop_order_by {
  id: order_by
}

# aggregate var_samp on columns
type playlists_var_samp_fields {
  id: Float
}

# order by var_samp() on columns of table "playlists"
input playlists_var_samp_order_by {
  id: order_by
}

# aggregate variance on columns
type playlists_variance_fields {
  id: Float
}

# order by variance() on columns of table "playlists"
input playlists_variance_order_by {
  id: order_by
}

# query root
type query_root {
  # fetch data from the table: "actors"
  actors(
    # distinct select on columns
    distinct_on: [actors_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [actors_order_by!]

    # filter the rows returned
    where: actors_bool_exp
  ): [actors!]!

  # fetch aggregated fields from the table: "actors"
  actors_aggregate(
    # distinct select on columns
    distinct_on: [actors_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [actors_order_by!]

    # filter the rows returned
    where: actors_bool_exp
  ): actors_aggregate!

  # fetch data from the table: "actors" using primary key columns
  actors_by_pk(id: Int!): actors

  # fetch data from the table: "albums"
  albums(
    # distinct select on columns
    distinct_on: [albums_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [albums_order_by!]

    # filter the rows returned
    where: albums_bool_exp
  ): [albums!]!

  # fetch aggregated fields from the table: "albums"
  albums_aggregate(
    # distinct select on columns
    distinct_on: [albums_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [albums_order_by!]

    # filter the rows returned
    where: albums_bool_exp
  ): albums_aggregate!

  # fetch data from the table: "albums" using primary key columns
  albums_by_pk(id: Int!): albums

  # fetch data from the table: "artists"
  artists(
    # distinct select on columns
    distinct_on: [artists_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [artists_order_by!]

    # filter the rows returned
    where: artists_bool_exp
  ): [artists!]!

  # fetch aggregated fields from the table: "artists"
  artists_aggregate(
    # distinct select on columns
    distinct_on: [artists_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [artists_order_by!]

    # filter the rows returned
    where: artists_bool_exp
  ): artists_aggregate!

  # fetch data from the table: "artists" using primary key columns
  artists_by_pk(id: Int!): artists

  # fetch data from the table: "categories"
  categories(
    # distinct select on columns
    distinct_on: [categories_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [categories_order_by!]

    # filter the rows returned
    where: categories_bool_exp
  ): [categories!]!

  # fetch aggregated fields from the table: "categories"
  categories_aggregate(
    # distinct select on columns
    distinct_on: [categories_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [categories_order_by!]

    # filter the rows returned
    where: categories_bool_exp
  ): categories_aggregate!

  # fetch data from the table: "categories" using primary key columns
  categories_by_pk(id: Int!): categories

  # fetch data from the table: "customers"
  customers(
    # distinct select on columns
    distinct_on: [customers_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [customers_order_by!]

    # filter the rows returned
    where: customers_bool_exp
  ): [customers!]!

  # fetch aggregated fields from the table: "customers"
  customers_aggregate(
    # distinct select on columns
    distinct_on: [customers_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [customers_order_by!]

    # filter the rows returned
    where: customers_bool_exp
  ): customers_aggregate!

  # fetch data from the table: "customers" using primary key columns
  customers_by_pk(id: Int!): customers

  # fetch data from the table: "employees"
  employees(
    # distinct select on columns
    distinct_on: [employees_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [employees_order_by!]

    # filter the rows returned
    where: employees_bool_exp
  ): [employees!]!

  # fetch aggregated fields from the table: "employees"
  employees_aggregate(
    # distinct select on columns
    distinct_on: [employees_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [employees_order_by!]

    # filter the rows returned
    where: employees_bool_exp
  ): employees_aggregate!

  # fetch data from the table: "employees" using primary key columns
  employees_by_pk(id: Int!): employees

  # fetch data from the table: "events"
  events(
    # distinct select on columns
    distinct_on: [events_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [events_order_by!]

    # filter the rows returned
    where: events_bool_exp
  ): [events!]!

  # fetch aggregated fields from the table: "events"
  events_aggregate(
    # distinct select on columns
    distinct_on: [events_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [events_order_by!]

    # filter the rows returned
    where: events_bool_exp
  ): events_aggregate!

  # fetch data from the table: "film_actor"
  film_actor(
    # distinct select on columns
    distinct_on: [film_actor_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [film_actor_order_by!]

    # filter the rows returned
    where: film_actor_bool_exp
  ): [film_actor!]!

  # fetch aggregated fields from the table: "film_actor"
  film_actor_aggregate(
    # distinct select on columns
    distinct_on: [film_actor_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [film_actor_order_by!]

    # filter the rows returned
    where: film_actor_bool_exp
  ): film_actor_aggregate!

  # fetch data from the table: "film_actor" using primary key columns
  film_actor_by_pk(actor_id: smallint!, film_id: smallint!): film_actor

  # fetch data from the table: "film_category"
  film_category(
    # distinct select on columns
    distinct_on: [film_category_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [film_category_order_by!]

    # filter the rows returned
    where: film_category_bool_exp
  ): [film_category!]!

  # fetch aggregated fields from the table: "film_category"
  film_category_aggregate(
    # distinct select on columns
    distinct_on: [film_category_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [film_category_order_by!]

    # filter the rows returned
    where: film_category_bool_exp
  ): film_category_aggregate!

  # fetch data from the table: "films"
  films(
    # distinct select on columns
    distinct_on: [films_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [films_order_by!]

    # filter the rows returned
    where: films_bool_exp
  ): [films!]!

  # fetch aggregated fields from the table: "films"
  films_aggregate(
    # distinct select on columns
    distinct_on: [films_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [films_order_by!]

    # filter the rows returned
    where: films_bool_exp
  ): films_aggregate!

  # fetch data from the table: "films" using primary key columns
  films_by_pk(id: Int!): films

  # fetch data from the table: "genres"
  genres(
    # distinct select on columns
    distinct_on: [genres_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [genres_order_by!]

    # filter the rows returned
    where: genres_bool_exp
  ): [genres!]!

  # fetch aggregated fields from the table: "genres"
  genres_aggregate(
    # distinct select on columns
    distinct_on: [genres_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [genres_order_by!]

    # filter the rows returned
    where: genres_bool_exp
  ): genres_aggregate!

  # fetch data from the table: "genres" using primary key columns
  genres_by_pk(id: Int!): genres

  # fetch data from the table: "invoice_lines"
  invoice_lines(
    # distinct select on columns
    distinct_on: [invoice_lines_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [invoice_lines_order_by!]

    # filter the rows returned
    where: invoice_lines_bool_exp
  ): [invoice_lines!]!

  # fetch aggregated fields from the table: "invoice_lines"
  invoice_lines_aggregate(
    # distinct select on columns
    distinct_on: [invoice_lines_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [invoice_lines_order_by!]

    # filter the rows returned
    where: invoice_lines_bool_exp
  ): invoice_lines_aggregate!

  # fetch data from the table: "invoice_lines" using primary key columns
  invoice_lines_by_pk(id: Int!): invoice_lines

  # fetch data from the table: "invoices"
  invoices(
    # distinct select on columns
    distinct_on: [invoices_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [invoices_order_by!]

    # filter the rows returned
    where: invoices_bool_exp
  ): [invoices!]!

  # fetch aggregated fields from the table: "invoices"
  invoices_aggregate(
    # distinct select on columns
    distinct_on: [invoices_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [invoices_order_by!]

    # filter the rows returned
    where: invoices_bool_exp
  ): invoices_aggregate!

  # fetch data from the table: "invoices" using primary key columns
  invoices_by_pk(id: Int!): invoices

  # fetch data from the table: "media_types"
  media_types(
    # distinct select on columns
    distinct_on: [media_types_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [media_types_order_by!]

    # filter the rows returned
    where: media_types_bool_exp
  ): [media_types!]!

  # fetch aggregated fields from the table: "media_types"
  media_types_aggregate(
    # distinct select on columns
    distinct_on: [media_types_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [media_types_order_by!]

    # filter the rows returned
    where: media_types_bool_exp
  ): media_types_aggregate!

  # fetch data from the table: "media_types" using primary key columns
  media_types_by_pk(id: Int!): media_types

  # fetch aggregated fields from the table: "my_table"
  my_table_aggregate_custom(
    # distinct select on columns
    distinct_on: [my_table_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [my_table_order_by!]

    # filter the rows returned
    where: my_table_bool_exp
  ): my_table_aggregate!

  # fetch data from the table: "my_table"
  my_table_custom(
    # distinct select on columns
    distinct_on: [my_table_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [my_table_order_by!]

    # filter the rows returned
    where: my_table_bool_exp
  ): [my_table!]!

  # fetch data from the table: "playlist_track"
  playlist_track(
    # distinct select on columns
    distinct_on: [playlist_track_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [playlist_track_order_by!]

    # filter the rows returned
    where: playlist_track_bool_exp
  ): [playlist_track!]!

  # fetch aggregated fields from the table: "playlist_track"
  playlist_track_aggregate(
    # distinct select on columns
    distinct_on: [playlist_track_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [playlist_track_order_by!]

    # filter the rows returned
    where: playlist_track_bool_exp
  ): playlist_track_aggregate!

  # fetch data from the table: "playlist_track" using primary key columns
  playlist_track_by_pk(playlist_id: Int!, track_id: Int!): playlist_track

  # fetch data from the table: "playlists"
  playlists(
    # distinct select on columns
    distinct_on: [playlists_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [playlists_order_by!]

    # filter the rows returned
    where: playlists_bool_exp
  ): [playlists!]!

  # fetch aggregated fields from the table: "playlists"
  playlists_aggregate(
    # distinct select on columns
    distinct_on: [playlists_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [playlists_order_by!]

    # filter the rows returned
    where: playlists_bool_exp
  ): playlists_aggregate!

  # fetch data from the table: "playlists" using primary key columns
  playlists_by_pk(id: Int!): playlists

  # execute function "search_article_ids" which returns "albums"
  search_article_ids(
    # input parameters for function "search_article_ids"
    args: search_article_ids_args!

    # distinct select on columns
    distinct_on: [albums_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [albums_order_by!]

    # filter the rows returned
    where: albums_bool_exp
  ): [albums!]!

  # execute function "search_article_ids" and query aggregates on result of table type "albums"
  search_article_ids_aggregate(
    # input parameters for function "search_article_ids"
    args: search_article_ids_args!

    # distinct select on columns
    distinct_on: [albums_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [albums_order_by!]

    # filter the rows returned
    where: albums_bool_exp
  ): albums_aggregate!

  # fetch data from the table: "tracks"
  tracks(
    # distinct select on columns
    distinct_on: [tracks_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [tracks_order_by!]

    # filter the rows returned
    where: tracks_bool_exp
  ): [tracks!]!

  # fetch aggregated fields from the table: "tracks"
  tracks_aggregate(
    # distinct select on columns
    distinct_on: [tracks_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [tracks_order_by!]

    # filter the rows returned
    where: tracks_bool_exp
  ): tracks_aggregate!

  # fetch data from the table: "tracks" using primary key columns
  tracks_by_pk(id: Int!): tracks
}

input SampleInput {
  password: String!
  username: String!
}

type SampleOutput {
  accessToken: String!
}

input search_article_ids_args {
  article_ids: _int4
}

scalar smallint

# expression to compare columns of type smallint. All fields are combined with logical 'AND'.
input smallint_comparison_exp {
  _eq: smallint
  _gt: smallint
  _gte: smallint
  _in: [smallint!]
  _is_null: Boolean
  _lt: smallint
  _lte: smallint
  _neq: smallint
  _nin: [smallint!]
}

# expression to compare columns of type String. All fields are combined with logical 'AND'.
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String
  _ilike: String
  _in: [String!]
  _is_null: Boolean
  _like: String
  _lt: String
  _lte: String
  _neq: String
  _nilike: String
  _nin: [String!]
  _nlike: String
  _nsimilar: String
  _similar: String
}

# subscription root
type subscription_root {
  # fetch data from the table: "actors"
  actors(
    # distinct select on columns
    distinct_on: [actors_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [actors_order_by!]

    # filter the rows returned
    where: actors_bool_exp
  ): [actors!]!

  # fetch aggregated fields from the table: "actors"
  actors_aggregate(
    # distinct select on columns
    distinct_on: [actors_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [actors_order_by!]

    # filter the rows returned
    where: actors_bool_exp
  ): actors_aggregate!

  # fetch data from the table: "actors" using primary key columns
  actors_by_pk(id: Int!): actors

  # fetch data from the table: "albums"
  albums(
    # distinct select on columns
    distinct_on: [albums_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [albums_order_by!]

    # filter the rows returned
    where: albums_bool_exp
  ): [albums!]!

  # fetch aggregated fields from the table: "albums"
  albums_aggregate(
    # distinct select on columns
    distinct_on: [albums_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [albums_order_by!]

    # filter the rows returned
    where: albums_bool_exp
  ): albums_aggregate!

  # fetch data from the table: "albums" using primary key columns
  albums_by_pk(id: Int!): albums

  # fetch data from the table: "artists"
  artists(
    # distinct select on columns
    distinct_on: [artists_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [artists_order_by!]

    # filter the rows returned
    where: artists_bool_exp
  ): [artists!]!

  # fetch aggregated fields from the table: "artists"
  artists_aggregate(
    # distinct select on columns
    distinct_on: [artists_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [artists_order_by!]

    # filter the rows returned
    where: artists_bool_exp
  ): artists_aggregate!

  # fetch data from the table: "artists" using primary key columns
  artists_by_pk(id: Int!): artists

  # fetch data from the table: "categories"
  categories(
    # distinct select on columns
    distinct_on: [categories_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [categories_order_by!]

    # filter the rows returned
    where: categories_bool_exp
  ): [categories!]!

  # fetch aggregated fields from the table: "categories"
  categories_aggregate(
    # distinct select on columns
    distinct_on: [categories_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [categories_order_by!]

    # filter the rows returned
    where: categories_bool_exp
  ): categories_aggregate!

  # fetch data from the table: "categories" using primary key columns
  categories_by_pk(id: Int!): categories

  # fetch data from the table: "customers"
  customers(
    # distinct select on columns
    distinct_on: [customers_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [customers_order_by!]

    # filter the rows returned
    where: customers_bool_exp
  ): [customers!]!

  # fetch aggregated fields from the table: "customers"
  customers_aggregate(
    # distinct select on columns
    distinct_on: [customers_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [customers_order_by!]

    # filter the rows returned
    where: customers_bool_exp
  ): customers_aggregate!

  # fetch data from the table: "customers" using primary key columns
  customers_by_pk(id: Int!): customers

  # fetch data from the table: "employees"
  employees(
    # distinct select on columns
    distinct_on: [employees_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [employees_order_by!]

    # filter the rows returned
    where: employees_bool_exp
  ): [employees!]!

  # fetch aggregated fields from the table: "employees"
  employees_aggregate(
    # distinct select on columns
    distinct_on: [employees_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [employees_order_by!]

    # filter the rows returned
    where: employees_bool_exp
  ): employees_aggregate!

  # fetch data from the table: "employees" using primary key columns
  employees_by_pk(id: Int!): employees

  # fetch data from the table: "events"
  events(
    # distinct select on columns
    distinct_on: [events_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [events_order_by!]

    # filter the rows returned
    where: events_bool_exp
  ): [events!]!

  # fetch aggregated fields from the table: "events"
  events_aggregate(
    # distinct select on columns
    distinct_on: [events_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [events_order_by!]

    # filter the rows returned
    where: events_bool_exp
  ): events_aggregate!

  # fetch data from the table: "film_actor"
  film_actor(
    # distinct select on columns
    distinct_on: [film_actor_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [film_actor_order_by!]

    # filter the rows returned
    where: film_actor_bool_exp
  ): [film_actor!]!

  # fetch aggregated fields from the table: "film_actor"
  film_actor_aggregate(
    # distinct select on columns
    distinct_on: [film_actor_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [film_actor_order_by!]

    # filter the rows returned
    where: film_actor_bool_exp
  ): film_actor_aggregate!

  # fetch data from the table: "film_actor" using primary key columns
  film_actor_by_pk(actor_id: smallint!, film_id: smallint!): film_actor

  # fetch data from the table: "film_category"
  film_category(
    # distinct select on columns
    distinct_on: [film_category_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [film_category_order_by!]

    # filter the rows returned
    where: film_category_bool_exp
  ): [film_category!]!

  # fetch aggregated fields from the table: "film_category"
  film_category_aggregate(
    # distinct select on columns
    distinct_on: [film_category_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [film_category_order_by!]

    # filter the rows returned
    where: film_category_bool_exp
  ): film_category_aggregate!

  # fetch data from the table: "films"
  films(
    # distinct select on columns
    distinct_on: [films_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [films_order_by!]

    # filter the rows returned
    where: films_bool_exp
  ): [films!]!

  # fetch aggregated fields from the table: "films"
  films_aggregate(
    # distinct select on columns
    distinct_on: [films_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [films_order_by!]

    # filter the rows returned
    where: films_bool_exp
  ): films_aggregate!

  # fetch data from the table: "films" using primary key columns
  films_by_pk(id: Int!): films

  # fetch data from the table: "genres"
  genres(
    # distinct select on columns
    distinct_on: [genres_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [genres_order_by!]

    # filter the rows returned
    where: genres_bool_exp
  ): [genres!]!

  # fetch aggregated fields from the table: "genres"
  genres_aggregate(
    # distinct select on columns
    distinct_on: [genres_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [genres_order_by!]

    # filter the rows returned
    where: genres_bool_exp
  ): genres_aggregate!

  # fetch data from the table: "genres" using primary key columns
  genres_by_pk(id: Int!): genres

  # fetch data from the table: "invoice_lines"
  invoice_lines(
    # distinct select on columns
    distinct_on: [invoice_lines_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [invoice_lines_order_by!]

    # filter the rows returned
    where: invoice_lines_bool_exp
  ): [invoice_lines!]!

  # fetch aggregated fields from the table: "invoice_lines"
  invoice_lines_aggregate(
    # distinct select on columns
    distinct_on: [invoice_lines_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [invoice_lines_order_by!]

    # filter the rows returned
    where: invoice_lines_bool_exp
  ): invoice_lines_aggregate!

  # fetch data from the table: "invoice_lines" using primary key columns
  invoice_lines_by_pk(id: Int!): invoice_lines

  # fetch data from the table: "invoices"
  invoices(
    # distinct select on columns
    distinct_on: [invoices_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [invoices_order_by!]

    # filter the rows returned
    where: invoices_bool_exp
  ): [invoices!]!

  # fetch aggregated fields from the table: "invoices"
  invoices_aggregate(
    # distinct select on columns
    distinct_on: [invoices_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [invoices_order_by!]

    # filter the rows returned
    where: invoices_bool_exp
  ): invoices_aggregate!

  # fetch data from the table: "invoices" using primary key columns
  invoices_by_pk(id: Int!): invoices

  # fetch data from the table: "media_types"
  media_types(
    # distinct select on columns
    distinct_on: [media_types_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [media_types_order_by!]

    # filter the rows returned
    where: media_types_bool_exp
  ): [media_types!]!

  # fetch aggregated fields from the table: "media_types"
  media_types_aggregate(
    # distinct select on columns
    distinct_on: [media_types_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [media_types_order_by!]

    # filter the rows returned
    where: media_types_bool_exp
  ): media_types_aggregate!

  # fetch data from the table: "media_types" using primary key columns
  media_types_by_pk(id: Int!): media_types

  # fetch aggregated fields from the table: "my_table"
  my_table_aggregate_custom(
    # distinct select on columns
    distinct_on: [my_table_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [my_table_order_by!]

    # filter the rows returned
    where: my_table_bool_exp
  ): my_table_aggregate!

  # fetch data from the table: "my_table"
  my_table_custom(
    # distinct select on columns
    distinct_on: [my_table_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [my_table_order_by!]

    # filter the rows returned
    where: my_table_bool_exp
  ): [my_table!]!

  # fetch data from the table: "playlist_track"
  playlist_track(
    # distinct select on columns
    distinct_on: [playlist_track_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [playlist_track_order_by!]

    # filter the rows returned
    where: playlist_track_bool_exp
  ): [playlist_track!]!

  # fetch aggregated fields from the table: "playlist_track"
  playlist_track_aggregate(
    # distinct select on columns
    distinct_on: [playlist_track_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [playlist_track_order_by!]

    # filter the rows returned
    where: playlist_track_bool_exp
  ): playlist_track_aggregate!

  # fetch data from the table: "playlist_track" using primary key columns
  playlist_track_by_pk(playlist_id: Int!, track_id: Int!): playlist_track

  # fetch data from the table: "playlists"
  playlists(
    # distinct select on columns
    distinct_on: [playlists_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [playlists_order_by!]

    # filter the rows returned
    where: playlists_bool_exp
  ): [playlists!]!

  # fetch aggregated fields from the table: "playlists"
  playlists_aggregate(
    # distinct select on columns
    distinct_on: [playlists_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [playlists_order_by!]

    # filter the rows returned
    where: playlists_bool_exp
  ): playlists_aggregate!

  # fetch data from the table: "playlists" using primary key columns
  playlists_by_pk(id: Int!): playlists

  # execute function "search_article_ids" which returns "albums"
  search_article_ids(
    # input parameters for function "search_article_ids"
    args: search_article_ids_args!

    # distinct select on columns
    distinct_on: [albums_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [albums_order_by!]

    # filter the rows returned
    where: albums_bool_exp
  ): [albums!]!

  # execute function "search_article_ids" and query aggregates on result of table type "albums"
  search_article_ids_aggregate(
    # input parameters for function "search_article_ids"
    args: search_article_ids_args!

    # distinct select on columns
    distinct_on: [albums_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [albums_order_by!]

    # filter the rows returned
    where: albums_bool_exp
  ): albums_aggregate!

  # fetch data from the table: "tracks"
  tracks(
    # distinct select on columns
    distinct_on: [tracks_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [tracks_order_by!]

    # filter the rows returned
    where: tracks_bool_exp
  ): [tracks!]!

  # fetch aggregated fields from the table: "tracks"
  tracks_aggregate(
    # distinct select on columns
    distinct_on: [tracks_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [tracks_order_by!]

    # filter the rows returned
    where: tracks_bool_exp
  ): tracks_aggregate!

  # fetch data from the table: "tracks" using primary key columns
  tracks_by_pk(id: Int!): tracks
}

scalar timestamp

# expression to compare columns of type timestamp. All fields are combined with logical 'AND'.
input timestamp_comparison_exp {
  _eq: timestamp
  _gt: timestamp
  _gte: timestamp
  _in: [timestamp!]
  _is_null: Boolean
  _lt: timestamp
  _lte: timestamp
  _neq: timestamp
  _nin: [timestamp!]
}

scalar timestamptz

# expression to compare columns of type timestamptz. All fields are combined with logical 'AND'.
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

# columns and relationships of "tracks"
type tracks {
  # An object relationship
  album: albums
  album_id: Int
  bytes: Int
  composer: String

  # An object relationship
  genre: genres
  genre_id: Int
  id: Int!

  # An array relationship
  invoice_lines(
    # distinct select on columns
    distinct_on: [invoice_lines_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [invoice_lines_order_by!]

    # filter the rows returned
    where: invoice_lines_bool_exp
  ): [invoice_lines!]!

  # An aggregated array relationship
  invoice_lines_aggregate(
    # distinct select on columns
    distinct_on: [invoice_lines_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [invoice_lines_order_by!]

    # filter the rows returned
    where: invoice_lines_bool_exp
  ): invoice_lines_aggregate!

  # An object relationship
  media_type: media_types!
  media_type_id: Int!
  milliseconds: Int!
  name: String!

  # An array relationship
  playlist_tracks(
    # distinct select on columns
    distinct_on: [playlist_track_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [playlist_track_order_by!]

    # filter the rows returned
    where: playlist_track_bool_exp
  ): [playlist_track!]!

  # An aggregated array relationship
  playlist_tracks_aggregate(
    # distinct select on columns
    distinct_on: [playlist_track_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [playlist_track_order_by!]

    # filter the rows returned
    where: playlist_track_bool_exp
  ): playlist_track_aggregate!
  unit_price: numeric!
}

# aggregated selection of "tracks"
type tracks_aggregate {
  aggregate: tracks_aggregate_fields
  nodes: [tracks!]!
}

# aggregate fields of "tracks"
type tracks_aggregate_fields {
  avg: tracks_avg_fields
  count(columns: [tracks_select_column!], distinct: Boolean): Int
  max: tracks_max_fields
  min: tracks_min_fields
  stddev: tracks_stddev_fields
  stddev_pop: tracks_stddev_pop_fields
  stddev_samp: tracks_stddev_samp_fields
  sum: tracks_sum_fields
  var_pop: tracks_var_pop_fields
  var_samp: tracks_var_samp_fields
  variance: tracks_variance_fields
}

# order by aggregate values of table "tracks"
input tracks_aggregate_order_by {
  avg: tracks_avg_order_by
  count: order_by
  max: tracks_max_order_by
  min: tracks_min_order_by
  stddev: tracks_stddev_order_by
  stddev_pop: tracks_stddev_pop_order_by
  stddev_samp: tracks_stddev_samp_order_by
  sum: tracks_sum_order_by
  var_pop: tracks_var_pop_order_by
  var_samp: tracks_var_samp_order_by
  variance: tracks_variance_order_by
}

# input type for inserting array relation for remote table "tracks"
input tracks_arr_rel_insert_input {
  data: [tracks_insert_input!]!
  on_conflict: tracks_on_conflict
}

# aggregate avg on columns
type tracks_avg_fields {
  album_id: Float
  bytes: Float
  genre_id: Float
  id: Float
  media_type_id: Float
  milliseconds: Float
  unit_price: Float
}

# order by avg() on columns of table "tracks"
input tracks_avg_order_by {
  album_id: order_by
  bytes: order_by
  genre_id: order_by
  id: order_by
  media_type_id: order_by
  milliseconds: order_by
  unit_price: order_by
}

# Boolean expression to filter rows from the table "tracks". All fields are combined with a logical 'AND'.
input tracks_bool_exp {
  _and: [tracks_bool_exp]
  _not: tracks_bool_exp
  _or: [tracks_bool_exp]
  album: albums_bool_exp
  album_id: Int_comparison_exp
  bytes: Int_comparison_exp
  composer: String_comparison_exp
  genre: genres_bool_exp
  genre_id: Int_comparison_exp
  id: Int_comparison_exp
  invoice_lines: invoice_lines_bool_exp
  media_type: media_types_bool_exp
  media_type_id: Int_comparison_exp
  milliseconds: Int_comparison_exp
  name: String_comparison_exp
  playlist_tracks: playlist_track_bool_exp
  unit_price: numeric_comparison_exp
}

# unique or primary key constraints on table "tracks"
enum tracks_constraint {
  # unique or primary key constraint
  pk_tracks
}

# input type for incrementing integer column in table "tracks"
input tracks_inc_input {
  album_id: Int
  bytes: Int
  genre_id: Int
  id: Int
  media_type_id: Int
  milliseconds: Int
  unit_price: numeric
}

# input type for inserting data into table "tracks"
input tracks_insert_input {
  album: albums_obj_rel_insert_input
  album_id: Int
  bytes: Int
  composer: String
  genre: genres_obj_rel_insert_input
  genre_id: Int
  id: Int
  invoice_lines: invoice_lines_arr_rel_insert_input
  media_type: media_types_obj_rel_insert_input
  media_type_id: Int
  milliseconds: Int
  name: String
  playlist_tracks: playlist_track_arr_rel_insert_input
  unit_price: numeric
}

# aggregate max on columns
type tracks_max_fields {
  album_id: Int
  bytes: Int
  composer: String
  genre_id: Int
  id: Int
  media_type_id: Int
  milliseconds: Int
  name: String
  unit_price: numeric
}

# order by max() on columns of table "tracks"
input tracks_max_order_by {
  album_id: order_by
  bytes: order_by
  composer: order_by
  genre_id: order_by
  id: order_by
  media_type_id: order_by
  milliseconds: order_by
  name: order_by
  unit_price: order_by
}

# aggregate min on columns
type tracks_min_fields {
  album_id: Int
  bytes: Int
  composer: String
  genre_id: Int
  id: Int
  media_type_id: Int
  milliseconds: Int
  name: String
  unit_price: numeric
}

# order by min() on columns of table "tracks"
input tracks_min_order_by {
  album_id: order_by
  bytes: order_by
  composer: order_by
  genre_id: order_by
  id: order_by
  media_type_id: order_by
  milliseconds: order_by
  name: order_by
  unit_price: order_by
}

# response of any mutation on the table "tracks"
type tracks_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [tracks!]!
}

# input type for inserting object relation for remote table "tracks"
input tracks_obj_rel_insert_input {
  data: tracks_insert_input!
  on_conflict: tracks_on_conflict
}

# on conflict condition type for table "tracks"
input tracks_on_conflict {
  constraint: tracks_constraint!
  update_columns: [tracks_update_column!]!
  where: tracks_bool_exp
}

# ordering options when selecting data from "tracks"
input tracks_order_by {
  album: albums_order_by
  album_id: order_by
  bytes: order_by
  composer: order_by
  genre: genres_order_by
  genre_id: order_by
  id: order_by
  invoice_lines_aggregate: invoice_lines_aggregate_order_by
  media_type: media_types_order_by
  media_type_id: order_by
  milliseconds: order_by
  name: order_by
  playlist_tracks_aggregate: playlist_track_aggregate_order_by
  unit_price: order_by
}

# primary key columns input for table: "tracks"
input tracks_pk_columns_input {
  id: Int!
}

# select columns of table "tracks"
enum tracks_select_column {
  # column name
  album_id

  # column name
  bytes

  # column name
  composer

  # column name
  genre_id

  # column name
  id

  # column name
  media_type_id

  # column name
  milliseconds

  # column name
  name

  # column name
  unit_price
}

# input type for updating data in table "tracks"
input tracks_set_input {
  album_id: Int
  bytes: Int
  composer: String
  genre_id: Int
  id: Int
  media_type_id: Int
  milliseconds: Int
  name: String
  unit_price: numeric
}

# aggregate stddev on columns
type tracks_stddev_fields {
  album_id: Float
  bytes: Float
  genre_id: Float
  id: Float
  media_type_id: Float
  milliseconds: Float
  unit_price: Float
}

# order by stddev() on columns of table "tracks"
input tracks_stddev_order_by {
  album_id: order_by
  bytes: order_by
  genre_id: order_by
  id: order_by
  media_type_id: order_by
  milliseconds: order_by
  unit_price: order_by
}

# aggregate stddev_pop on columns
type tracks_stddev_pop_fields {
  album_id: Float
  bytes: Float
  genre_id: Float
  id: Float
  media_type_id: Float
  milliseconds: Float
  unit_price: Float
}

# order by stddev_pop() on columns of table "tracks"
input tracks_stddev_pop_order_by {
  album_id: order_by
  bytes: order_by
  genre_id: order_by
  id: order_by
  media_type_id: order_by
  milliseconds: order_by
  unit_price: order_by
}

# aggregate stddev_samp on columns
type tracks_stddev_samp_fields {
  album_id: Float
  bytes: Float
  genre_id: Float
  id: Float
  media_type_id: Float
  milliseconds: Float
  unit_price: Float
}

# order by stddev_samp() on columns of table "tracks"
input tracks_stddev_samp_order_by {
  album_id: order_by
  bytes: order_by
  genre_id: order_by
  id: order_by
  media_type_id: order_by
  milliseconds: order_by
  unit_price: order_by
}

# aggregate sum on columns
type tracks_sum_fields {
  album_id: Int
  bytes: Int
  genre_id: Int
  id: Int
  media_type_id: Int
  milliseconds: Int
  unit_price: numeric
}

# order by sum() on columns of table "tracks"
input tracks_sum_order_by {
  album_id: order_by
  bytes: order_by
  genre_id: order_by
  id: order_by
  media_type_id: order_by
  milliseconds: order_by
  unit_price: order_by
}

# update columns of table "tracks"
enum tracks_update_column {
  # column name
  album_id

  # column name
  bytes

  # column name
  composer

  # column name
  genre_id

  # column name
  id

  # column name
  media_type_id

  # column name
  milliseconds

  # column name
  name

  # column name
  unit_price
}

# aggregate var_pop on columns
type tracks_var_pop_fields {
  album_id: Float
  bytes: Float
  genre_id: Float
  id: Float
  media_type_id: Float
  milliseconds: Float
  unit_price: Float
}

# order by var_pop() on columns of table "tracks"
input tracks_var_pop_order_by {
  album_id: order_by
  bytes: order_by
  genre_id: order_by
  id: order_by
  media_type_id: order_by
  milliseconds: order_by
  unit_price: order_by
}

# aggregate var_samp on columns
type tracks_var_samp_fields {
  album_id: Float
  bytes: Float
  genre_id: Float
  id: Float
  media_type_id: Float
  milliseconds: Float
  unit_price: Float
}

# order by var_samp() on columns of table "tracks"
input tracks_var_samp_order_by {
  album_id: order_by
  bytes: order_by
  genre_id: order_by
  id: order_by
  media_type_id: order_by
  milliseconds: order_by
  unit_price: order_by
}

# aggregate variance on columns
type tracks_variance_fields {
  album_id: Float
  bytes: Float
  genre_id: Float
  id: Float
  media_type_id: Float
  milliseconds: Float
  unit_price: Float
}

# order by variance() on columns of table "tracks"
input tracks_variance_order_by {
  album_id: order_by
  bytes: order_by
  genre_id: order_by
  id: order_by
  media_type_id: order_by
  milliseconds: order_by
  unit_price: order_by
}

scalar tsvector

# expression to compare columns of type tsvector. All fields are combined with logical 'AND'.
input tsvector_comparison_exp {
  _eq: tsvector
  _gt: tsvector
  _gte: tsvector
  _in: [tsvector!]
  _is_null: Boolean
  _lt: tsvector
  _lte: tsvector
  _neq: tsvector
  _nin: [tsvector!]
}

scalar uuid

